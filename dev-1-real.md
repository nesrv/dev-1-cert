## 1 Какие утверждения справедливы при выполнении запросов?

Выберите один или несколько ответов:

* можно выполнить оператор, не подготавливая его, и сразу получить все строки результата
* можно выполнить оператор, не подготавливая его, и получать результат построчно
* можно подготовить оператор, затем выполнить его, и разом получить все строки результата
* можно подготовить оператор, затем выполнить его, и получать результат построчно
* ничего из перечисленного

## Ответ от DeepSeek

В PostgreSQL верны **все четыре утверждения**:

1. **Можно выполнить оператор, не подготавливая его, и сразу получить все строки результата**  
   - Стандартный способ выполнения запросов через `SELECT`.  
   - Пример:  
     ```sql
     SELECT * FROM users; -- Все строки возвращаются сразу
     ```

2. **Можно выполнить оператор, не подготавливая его, и получать результат построчно**  
   - Используется для больших результатов через **курсоры**:  
     ```sql
     BEGIN;
     DECLARE cur CURSOR FOR SELECT * FROM large_table;
     FETCH 100 FROM cur; -- Получение 100 строк
     -- Далее FETCH для следующих строк
     COMMIT;
     ```

3. **Можно подготовить оператор, затем выполнить его, и разом получить все строки результата**  
   - Подготовленные запросы (`PREPARE`) с последующим `EXECUTE`:  
     ```sql
     PREPARE user_query AS SELECT * FROM users WHERE age > $1;
     EXECUTE user_query(18); -- Все строки сразу
     ```

4. **Можно подготовить оператор, затем выполнить его, и получать результат построчно**  
   - Комбинация подготовки и курсоров:  
     ```sql
     PREPARE user_query AS SELECT * FROM users WHERE age > $1;
     BEGIN;
     DECLARE cur CURSOR FOR EXECUTE user_query(18);
     FETCH 1 FROM cur; -- Построчное чтение
     -- ...
     COMMIT;
     ```

### Ключевые особенности:
- **Без подготовки** — простые запросы, но возможны SQL-инъекции (если не экранировать параметры).  
- **С подготовкой** — безопаснее, особенно для повторяющихся запросов.  
- **Построчное чтение** — снижает нагрузку на память при больших результатах.  

**Итог:** Все варианты корректны и поддерживаются PostgreSQL. Выбор зависит от задачи.


## Правильные утверждения(Yandex) думаю, что это неполностью верный ответ:

“можно выполнить оператор, не подготавливая его, и сразу получить все строки результата”
“можно подготовить оператор, затем выполнить его, и разом получить все строки результата”
“можно подготовить оператор, затем выполнить его, и получать результат построчно”

Объяснение:

Первый вариант возможен при использовании простых запросов без параметров, когда оператор выполняется напрямую и возвращает весь результат сразу.
Второй вариант - это типичный сценарий использования подготовленных операторов (prepared statements), когда после подготовки оператор выполняется и возвращает все данные разом.
Третий вариант также допустим, когда после подготовки оператора результат можно получать построчно, что может быть полезно для больших наборов данных.
Вариант без подготовки оператора и построчного получения результата (второй в списке) обычно не используется, так как это менее эффективно и менее безопасно из-за отсутствия возможности параметризации запроса.


## 2 В сеансе выполнены команды:


```sql
CREATE TABLE t (id int);

CREATE FUNCTION count_t() RETURNS bigint
LANGUAGE SQL
RETURN (SELECT count(*) FROM public.t);

DROP TABLE t CASCADE;

--Чем завершится вызов функции?

SELECT count_t();

```
Выберите один или несколько ответов:
завершится ошибкой из-за отсутствия таблицы
завершится ошибкой из-за отсутствия функции
функция вернет 0
функция не была создана из-за неверного синтаксиса, ее вызов завершится ошибкой
ничего из перечисленного

### Правильный ответ: “завершится ошибкой из-за отсутствия таблицы”

Объяснение:

Сначала создается таблица t с одним столбцом id
Затем создается функция count_t(), которая возвращает количество строк в таблице t
После этого таблица t удаляется с параметром CASCADE, который удаляет все зависимые объекты
При вызове функции count_t() возникнет ошибка, так как:
Функция все еще существует
Но таблица, к которой она обращается, была удалена
SELECT count(*) не может выполниться из-за отсутствия таблицы
Остальные варианты неверны:

Функция была создана корректно, поэтому вариант с неверным синтаксисом не подходит
Функция не вернет 0, так как возникнет ошибка до подсчета
Вариант “ничего из перечисленного” не подходит, так как описана именно ошибка из-за отсутствия таблицы


## 3 Что может передаваться в качестве контекста в триггерную функцию для триггеров уровня оператора BEFORE STATEMENT в постгрес?

Выберите один или несколько ответов:
* запись OLD
* запись NEW
* таблица OLD TABLE
* таблица NEW TABLE
* переменная TG_OP 
* переменная TG_LEVEL
* ничего из перечисленного


### DeepSeek

Для триггеров уровня оператора **`BEFORE STATEMENT`** в PostgreSQL доступны следующие элементы контекста:

### Правильные ответы:
✅ **Переменная `TG_OP`**  
- Содержит тип операции, вызвавшей триггер (`INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`).

✅ **Переменная `TG_LEVEL`**  
- Указывает уровень триггера: `'STATEMENT'` (для операторных триггеров) или `'ROW'` (для строчных).

---

### Неправильные ответы:
❌ **Запись `OLD`**  
- Доступна только в триггерах уровня строки (`FOR EACH ROW`) для операций `UPDATE`/`DELETE`.

❌ **Запись `NEW`**  
- Доступна только в триггерах уровня строки (`FOR EACH ROW`) для операций `INSERT`/`UPDATE`.

❌ **Таблица `OLD TABLE`**  
- Доступна только в триггерах **`AFTER STATEMENT`** с использованием переходных таблиц (transition tables).

❌ **Таблица `NEW TABLE`**  
- Аналогично: только для `AFTER STATEMENT` с переходными таблицами.

❌ **Ничего из перечисленного**  
- Неверно, так как `TG_OP` и `TG_LEVEL` всегда доступны.

---

### Пример триггера `BEFORE STATEMENT`:
```sql
CREATE OR REPLACE FUNCTION before_statement_log()
RETURNS TRIGGER AS $$
BEGIN
    RAISE NOTICE 'Операция: %, Уровень: %', TG_OP, TG_LEVEL;
    RETURN NULL;  -- Для BEFORE STATEMENT возвращаемое значение игнорируется
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_statement
BEFORE INSERT OR UPDATE OR DELETE ON my_table
FOR EACH STATEMENT  -- Уровень оператора
EXECUTE FUNCTION before_statement_log();
```

### Ключевые особенности:
1. **Доступные переменные**:
   - `TG_OP` — тип операции.
   - `TG_LEVEL` — уровень триггера (`'STATEMENT'`).
   - Также доступны: `TG_TABLE_NAME`, `TG_WHEN` (BEFORE/AFTER), `TG_TAG` (текст SQL-команды).

2. **Ограничения**:
   - Нет доступа к данным строк (`OLD`/`NEW`).
   - Нельзя использовать переходные таблицы (`OLD TABLE`/`NEW TABLE`).

3. **Применение**:
   - Логирование начала транзакций.
   - Проверка условий перед выполнением операций (например, запрет изменений в определенное время).

**Итог:** Для `BEFORE STATEMENT` верны только варианты с `TG_OP` и `TG_LEVEL`.


### Правильные ответы от Yandex(не точно):

таблица OLD TABLE
таблица NEW TABLE
переменная TG_OP


Объяснение:

Для триггеров уровня оператора (BEFORE STATEMENT) действуют следующие правила:

OLD и NEW записи НЕ доступны, так как на уровне оператора триггер срабатывает до обработки любых строк
OLD TABLE и NEW TABLE доступны, потому что они содержат все затронутые строки до выполнения операции
TG_OP доступна всегда, она содержит тип операции (INSERT/UPDATE/DELETE)
TG_LEVEL не является валидной переменной в контексте PostgreSQL
Таким образом, в качестве контекста для BEFORE STATEMENT триггера могут передаваться только таблицы OLD TABLE и NEW TABLE, а также переменная TG_OP.



## еще один ответ от яндекс

Правильный ответ: ничего из перечисленного.

Для триггеров уровня оператора (FOR EACH STATEMENT) в PostgreSQL:

Переменные OLD и NEW недоступны, так как они работают только с отдельными строками
Таблицы OLD TABLE и NEW TABLE недоступны до выполнения оператора
Переменная TG_OP (тип операции) и TG_LEVEL (уровень триггера) также не передаются, так как они актуальны для других типов триггеров
Триггерные функции для операторов с параметром FOR EACH STATEMENT должны возвращать NULL и не получают доступ к конкретным данным строк или таблицам до выполнения операции.


## 4 Что может передаваться в качестве контекста в триггерную функцию для строчных табличных триггеров BEFORE ROW в Postgres?

Выберите один или несколько ответов:
запись OLD +
запись NEW +
таблица OLD TABLE
таблица NEW TABLE
переменная TG_OP +
переменная TG_LEVEL +
ничего из перечисленного

### DeepSeek

Для строчных (ROW-level) триггеров **BEFORE ROW** в PostgreSQL доступны следующие элементы контекста:

### Правильные ответы:
✅ **Запись OLD**  
- Содержит состояние строки ДО изменений (доступна только для операций UPDATE и DELETE)

✅ **Запись NEW**  
- Содержит новое состояние строки (доступна для INSERT и UPDATE)  
- Может быть изменена в BEFORE-триггере

✅ **Переменная TG_OP**  
- Указывает тип операции: 'INSERT', 'UPDATE', 'DELETE' или 'TRUNCATE'

✅ **Переменная TG_LEVEL**  
- Всегда содержит значение 'ROW' для строчных триггеров

### Неправильные ответы:
❌ **Таблица OLD TABLE**  
- Доступна только для триггеров AFTER STATEMENT с переходными таблицами

❌ **Таблица NEW TABLE**  
- Также доступна только для AFTER STATEMENT с переходными таблицами

❌ **Ничего из перечисленного**  
- Неверно, так как OLD, NEW, TG_OP и TG_LEVEL доступны

### Пример использования:
```sql
CREATE OR REPLACE FUNCTION before_row_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        NEW.modified_at = NOW(); -- Изменяем данные перед сохранением
        RAISE NOTICE 'Изменение строки. Старое значение: %, Новое: %', OLD.some_field, NEW.some_field;
    ELSIF TG_OP = 'INSERT' THEN
        NEW.created_at = NOW(); -- Устанавливаем дату создания
    END IF;
    RETURN NEW; -- Важно вернуть NEW для INSERT/UPDATE
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_row
BEFORE INSERT OR UPDATE ON my_table
FOR EACH ROW
EXECUTE FUNCTION before_row_trigger();
```

### Ключевые особенности:
1. **OLD и NEW** - это записи строк, а не таблицы
2. **BEFORE ROW** позволяет изменять данные перед сохранением (через NEW)
3. **TG_OP** помогает определить тип операции
4. **TG_LEVEL** всегда 'ROW' для таких триггеров
5. Обязательно нужно вернуть NEW (для INSERT/UPDATE) или OLD (для DELETE)

**Итог:** Верны варианты с OLD, NEW, TG_OP и TG_LEVEL.


### еще ответ от яндекс

Правильные ответы:

* запись OLD
* запись NEW
* переменная TG_OP
* переменная TG_LEVEL

Обоснование:

Для триггеров BEFORE ROW доступны переменные OLD и NEW:
OLD содержит старую версию строки (для UPDATE/DELETE)
NEW содержит новую версию строки (для INSERT/UPDATE)
Также доступны системные переменные:
TG_OP (содержит тип операции: INSERT/UPDATE/DELETE)
TG_LEVEL (содержит уровень триггера: ROW)
Таблицы OLD TABLE и NEW TABLE недоступны для строчных триггеров, так как они используются только для триггеров уровня оператора (FOR EACH STATEMENT).




## Правильные ответы (или неправильный старый):

запись OLD
запись NEW
переменная TG_OP
Объяснение:
Для строчных табличных триггеров BEFORE ROW действуют следующие правила:

Доступны записи OLD и NEW:
OLD содержит текущее значение строки до изменения (для UPDATE/DELETE)
NEW содержит новое значение строки (для INSERT/UPDATE)
Таблицы OLD TABLE и NEW TABLE НЕ доступны, так как:
Они доступны только для триггеров уровня оператора (STATEMENT)
В ROW-триггерах обрабатывается только одна строка
TG_OP доступна всегда, она содержит тип операции (INSERT/UPDATE/DELETE)
TG_LEVEL не является валидной переменной в контексте PostgreSQL
Таким образом, для BEFORE ROW триггера в качестве контекста доступны только записи OLD и NEW, а также переменная TG_OP.

## 5 Определение каких объектов хранятся в системном каталоге pg_proc в постгрес?

Выберите один или несколько ответов:

* правила
* процедуры
* табличные триггеры
* триггеры событий
* функции
* ничего из перечисленного

## DeepSeek


В системном каталоге **`pg_proc`** PostgreSQL хранятся определения следующих объектов:

### Правильные ответы:
✅ **Функции (FUNCTION)**  
- Основное содержимое `pg_proc` - все пользовательские и встроенные функции (например, `lower()`, `now()`)
- Содержит их сигнатуры (аргументы, возвращаемый тип), изменчивость (`VOLATILE`/`STABLE`/`IMMUTABLE`) и тело (если написано на SQL или встроенном языке)

✅ **Процедуры (PROCEDURE)**  
- Начиная с PostgreSQL 11, процедуры (созданные через `CREATE PROCEDURE`) также хранятся в `pg_proc`, но с флагом `prokind = 'p'` (в отличие от функций, где `prokind = 'f'`)

### Неправильные ответы:
❌ **Правила (RULES)**  
- Хранятся в каталоге **`pg_rewrite`**

❌ **Табличные триггеры (TRIGGERS)**  
- Хранятся в **`pg_trigger`**

❌ **Триггеры событий (EVENT TRIGGERS)**  
- Хранятся в **`pg_event_trigger`**

❌ **Ничего из перечисленного**  
- Неверно, так как функции и процедуры точно хранятся в `pg_proc`

### Пример запроса к `pg_proc`:
```sql
SELECT proname, prokind, prosrc 
FROM pg_proc 
WHERE proname = 'lower';
```

Результат:
```
 proname | prokind |           prosrc           
---------+---------+---------------------------
 lower   | f       | SELECT pg_catalog.lower($1)
```

### Ключевые поля `pg_proc`:
- `proname` - имя функции/процедуры
- `prorettype` - тип возвращаемого значения
- `proargtypes` - типы аргументов
- `prosrc` - исходный код (для SQL-функций)
- `prokind` - `'f'` (функция) или `'p'` (процедура)

**Итог:** Только **функции** и **процедуры** хранятся в `pg_proc**. Остальные объекты - в других системных каталогах.


Правильные ответы:

процедуры
функции

Объяснение:
Согласно документации, в каталоге pg_proc хранится информация о:

обычных функциях
процедурах
агрегатных функциях
оконных функциях
В этот список не входят:

правила (они хранятся в других системных каталогах)
табличные триггеры (информация о них хранится в pg_trigger)
триггеры событий (они имеют свою отдельную структуру хранения)
Таким образом, из предложенных вариантов в pg_proc хранятся только процедуры и функции.

Где располагаются данные кластера (PGDATA) постгрес в виртуальной машине курса ?

Выберите один или несколько ответов:


* /var/lib/postgresql/16/main
* /etc/postgresql/16/main
* /usr/local/pgsql/data
* /usr/local/pgsql/data/pg_log
* /var/log/postgresql
* /opt/postgres

## DeepSeek

В виртуальной машине курса данные кластера PostgreSQL (PGDATA) по умолчанию располагаются по пути:

✅ **`/var/lib/postgresql/16/main`**

### Обоснование:
1. **Стандартное расположение для Debian/Ubuntu**:
   - В дистрибутивах на основе Debian (включая Ubuntu) PostgreSQL устанавливается через пакетный менеджер (`apt`)
   - PGDATA по умолчанию размещается в:
     ```
     /var/lib/postgresql/<версия>/<имя_кластера>
     ```
   - Для PostgreSQL 16: `/var/lib/postgresql/16/main`

2. **Почему не другие варианты**:
   - `/etc/postgresql/16/main` - содержит только конфигурационные файлы
   - `/usr/local/pgsql/data` - используется при ручной установке из исходников
   - `/usr/local/pgsql/data/pg_log` - нестандартный путь для логов
   - `/var/log/postgresql` - содержит логи, но не данные кластера
   - `/opt/postgres` - не используется в стандартной установке

3. **Как проверить**:
   ```bash
   sudo -u postgres psql -c "SHOW data_directory;"
   ```
   Вывод будет:
   ```
    data_directory       
   -----------------------
    /var/lib/postgresql/16/main
   ```

### Дополнительные сведения:
- Для других версий PostgreSQL путь будет содержать соответствующую версию (например, `14/main`)
- Конфигурационные файлы находятся в `/etc/postgresql/16/main`
- Логи сервера по умолчанию пишутся в `/var/log/postgresql`

**Итоговый ответ:** `/var/lib/postgresql/16/main`



Данные кластера PostgreSQL располагаются в каталоге /var/lib/postgresql/16/main.

Какие форматы pg_dump можно указать при создании резервной копии, чтобы восстановить утилитой pg_restore только отдельную таблицу?

Выберите один или несколько ответов:
plain
custom
directory
tar
ничего из перечисленного
Для восстановления отдельной таблицы с помощью утилиты pg_restore вам нужно создать резервную копию в формате custom или directory.

Где располагается журнал сервера в виртуальной машине курса?
Выберите один или несколько ответов:
/etc/postgresql/16/main
/usr/local/pgsql/data
/var/lib/postgresql/16/main
/usr/local/pgsql/data/pg_log
/opt/postgres
/var/log/postgresql
Журнал сервера PostgreSQL обычно располагается в каталоге /var/lib/postgresql/16/main. Однако точное местоположение может варьироваться в зависимости от операционной системы и настроек сервера.

Что может передаваться в качестве контекста в триггерную функцию для триггеров уровня оператора AFTER STATEMENT?
Выберите один или несколько ответов:
запись OLD
запись NEW
таблица OLD TABLE
таблица NEW TABLE
переменная TG_OP
переменная TG_LEVEL
ничего из перечисленного
В качестве контекста в триггерную функцию для триггеров уровня оператора AFTER STATEMENT может передаваться запись NEW.

Заголовок функции:
CREATE FUNCTION f(p integer) RETURNS SETOF integer STRICT AS ..
Для чего используется указание STRICT?
Выберите один или несколько ответов:
возвращаемое значение функции не может быть NULL
если значение параметра NULL, то функция должна сразу вернуть NULL
функция должна вернуть ровно одну строку
тип данных параметра должен соответствовать типу возвращаемого значения
ничего из перечисленного
Указание STRICT используется для того, чтобы возвращаемое значение функции не могло быть NULL.

Что из перечисленного справедливо для хранимых процедур?

Выберите один или несколько ответов:
могут управлять транзакциями
вызываются оператором CALL
не могут вызываться из функций
вызываются в контексте выражения
могут возвращать результат
Правильные ответы:

могут управлять транзакциями
вызываются оператором CALL
могут возвращать результат
Объяснение:

“Могут управлять транзакциями” - это ключевое преимущество процедур перед функциями. Именно для этого они были введены в PostgreSQL.
“Вызываются оператором CALL” - это верный способ вызова процедур, в отличие от функций, которые вызываются в контексте выражения.
“Могут возвращать результат” - вопреки распространенному мифу, процедуры могут возвращать результат, если это необходимо.
Неверные варианты:

“Не могут вызываться из функций” - нет явного ограничения на вызов процедур из функций
“Вызываются в контексте выражения” - это характеристика функций, а не процедур
Какой инструмент принято использовать в курсе для управления сервером?
Выберите один ответ:
pg_ctl
pg_ctlcluster
service
systemctl
Правильный ответ: pg_ctl

Объяснение:
pg_ctl является основным и универсальным инструментом для управления сервером PostgreSQL. Эта утилита:

Предоставляет полный контроль над сервером PostgreSQL
Поддерживает все основные операции: запуск, остановка, перезапуск
Работает на всех платформах
Имеет богатый набор параметров для тонкой настройки процесса управления
Остальные варианты являются либо специфичными для определенных систем, либо обертками над pg_ctl:

pg_ctlcluster используется только в Ubuntu при установке из пакетов ОС (это обертка над pg_ctl)
service и systemctl - это системные утилиты для управления службами в Linux, которые могут использоваться для запуска/остановки PostgreSQL, но не являются специфичными именно для PostgreSQL
Таким образом, pg_ctl является стандартным и рекомендуемым инструментом для управления сервером PostgreSQL.

Что может передаваться в качестве контекста в триггерную функцию для строчных табличных триггеров AFTER ROW?
Выберите один или несколько ответов:
запись OLD
запись NEW
таблица OLD TABLE
таблица NEW TABLE
переменная TG_OP
переменная TG_LEVEL
ничего из перечисленного
Правильные ответы:

запись OLD
запись NEW
переменная TG_OP
Объяснение:
Для строчных триггеров AFTER ROW в качестве контекста могут передаваться:

OLD - запись до изменения (для операций UPDATE и DELETE)
NEW - запись после изменения (для операций INSERT и UPDATE)
TG_OP - переменная, указывающая тип операции (INSERT, UPDATE или DELETE)
Неверные варианты:

OLD TABLE и NEW TABLE доступны только для триггеров уровня оператора (STATEMENT)
TG_LEVEL не является валидной переменной для триггеров
“Ничего из перечисленного” - неверный вариант, так как минимум TG_OP всегда доступна
Это важно для разработки триггерных функций, так как позволяет определить, какие данные доступны для обработки в момент срабатывания триггера.

Какие режимы можно указать для параметров процедур в постгрес?
Выберите один или несколько ответов:
IN
OUT
INOUT
VARIADIC
ничего из перечисленного
Правильные ответы:

IN
OUT
INOUT
VARIADIC
Объяснение:
В PostgreSQL действительно поддерживаются все четыре режима параметров:

IN - параметр только для чтения (значение передается в функцию)
OUT - параметр только для возврата значения из функции
INOUT - параметр, который можно и прочитать, и изменить
VARIADIC - параметр для передачи переменного количества аргументов
Вариант “ничего из перечисленного” неверный, так как все перечисленные режимы являются валидными для PostgreSQL.

Каждый из этих режимов имеет свое специфическое применение:

IN используется по умолчанию
OUT удобен для возврата нескольких значений
INOUT позволяет модифицировать переданный параметр
VARIADIC полезен при работе с неопределенным количеством аргументов
Это важная особенность PostgreSQL, которая позволяет гибко настраивать поведение функций и процедур.

Информация о ролях:
\du
List of roles
Role name | Attributes
-----------+------------------------------------------------------------
buyer |
employee |
postgres | Superuser, Create role, Create DB, Replication, Bypass RLS
student | Superuser
Информация о базе данных db:
\x
\list db
List of databases
-[ RECORD 1 ]-----+------------
Name | db
Owner | buyer
Encoding | UTF8
Locale Provider | libc
Collate | en_US.UTF-8
Ctype | en_US.UTF-8
ICU Locale |
ICU Rules |
Access privileges |
Информация схеме public в базе данных db:
\dn+ public
List of schemas
-[ RECORD 1 ]-----+---------------------------------------
Name | public
Owner | pg_database_owner
Access privileges | pg_database_owner=UC/pg_database_owner+
| =U/pg_database_owner
Description | standard public schema
Какие роли имеют права на создание объектов в схеме public?
Выберите один или несколько ответов:
buyer
employee
postgres
student
ни одна из перечисленных
Правильный ответ: postgres и student

Объяснение:

В схеме public права на создание объектов (U - usage) имеют:
Владелец схемы pg_database_owner (с правом создания объектов)
Все роли в системе (только просмотр объектов)
Из предложенных ролей:
postgres и student являются суперпользователями (superuser)
Суперпользователи имеют права на создание объектов в любой схеме
buyer и employee не имеют специальных прав и не являются владельцами схемы
employee вообще не имеет никаких особых атрибутов
Поскольку postgres и student - суперпользователи, они могут создавать объекты в схеме public, несмотря на ограничения, указанные в правах схемы.
Таким образом, только роли postgres и student имеют необходимые права для создания объектов в схеме public.

CREATE FUNCTION f() RETURNS int
BEGIN ATOMIC
SELECT 1;
END;
Выберите один или несколько ответов:
после выполнения будет создана функция на языке SQL
после выполнения будет создана функция на языке PL/pgSQL
используется синтаксис в стиле стандарта SQL
неверный синтаксис, команда завершится ошибкой
ничего из перечисленного
Правильные ответы:

используется синтаксис в стиле стандарта SQL
неверный синтаксис, команда завершится ошибкой
Объяснение:

В данном случае используется синтаксис, характерный для стандарта SQL (SQL/PSM), который включает:
BEGIN ATOMIC
END
RETURNS тип
Однако код содержит ошибки:
Пропущен язык определения функции (LANGUAGE)
Отсутствует RETURN в теле функции
SELECT 1 не будет возвращен как результат
Несмотря на ошибки, синтаксис явно указывает на SQL-стиль определения функций:
Использование BEGIN ATOMIC характерно для SQL стандарт
Отсутствует PL/pgSQL специфичный синтаксис
Функция не будет создана из-за синтаксических ошибок, поэтому варианты про успешное создание неверны.
Таким образом, код демонстрирует SQL-стиль определения функций, но содержит ошибки, из-за которых выполнение завершится с ошибкой.

Ниже представлены несколько реализаций функции num_rows, подсчитывающей количество записей в таблице, имя которой передано параметром.

Вариант 1.
CREATE OR REPLACE FUNCTION num_rows (table_name text) RETURNS integer AS $$
DECLARE
i bigint;
BEGIN
EXECUTE 'SELECT count(*) FROM $1' USING p INTO i;
RETURN i;
END;$$ LANGUAGE plpgsql;

Вариант 2.
CREATE OR REPLACE FUNCTION num_rows (table_name text) RETURNS integer AS $$
DECLARE
i bigint;
BEGIN
EXECUTE 'SELECT count(*) FROM ' || table_name INTO i;
RETURN i;
END;$$ LANGUAGE plpgsql;


Вариант 3.

CREATE OR REPLACE FUNCTION num_rows (table_name text) RETURNS integer AS $$
DECLARE
i bigint;
BEGIN
EXECUTE format('SELECT count(*) FROM %I', table_name) INTO i;
RETURN i;
END;$$ LANGUAGE plpgsql;

Вариант 4.
CREATE OR REPLACE FUNCTION num_rows (table_name text) RETURNS integer AS $$
DECLARE
i bigint;
BEGIN
EXECUTE format('SELECT count(*) FROM %L', table_name) INTO i;
RETURN i;
END;$$ LANGUAGE plpgsql;

Вариант 5.
CREATE OR REPLACE FUNCTION num_rows (table_name text) RETURNS integer AS $$
DECLARE
i bigint;
BEGIN
EXECUTE 'SELECT count(*) FROM ' || quote_ident(table_name) INTO i;
RETURN i;
END;$$ LANGUAGE plpgsql;

Отметьте варианты гарантирующие невозможность внедрения SQL-кода и корректно работающие с любыми именами таблиц.
Выберите один или несколько ответов:
Вариант 1.
Вариант 2.
Вариант 3.
Вариант 4.
Вариант 5.
Правильные ответы:

Вариант 3
Вариант 5
Объяснение:

Вариант 1 - НЕВЕРЕН
Использование USING с $1 некорректно в данном контексте
$1 используется для позиционных параметров в SQL-запросах, а не в EXECUTE
Вариант 2 - НЕВЕРЕН
Уязвим к SQL-инъекциям
Простое конкатенация строки без обработки может привести к уязвимостям
Вариант 3 - ВЕРЕН
Использует format() с %I
%I автоматически экранирует идентификаторы
Защищает от SQL-инъекций
Корректно работает с любыми именами таблиц
Вариант 4 - НЕВЕРЕН
Использует format() с %L
%L экранирует строку, а не идентификатор
Может привести к ошибкам при использовании зарезервированных слов
Вариант 5 - ВЕРЕН
Использует quote_ident()
Экранирует идентификаторы таблицы
Защищает от SQL-инъекций
Корректно работает с любыми именами таблиц
Таким образом, только варианты 3 и 5 обеспечивают безопасность от SQL-инъекций и корректную работу с любыми именами таблиц.

Какая команда psql показывает значение параметров конфигурации сервера?
Выберите один ответ:
\dc
\dconfig
\dp
\getenv
\list
\pset
ничего из перечисленного
Правильный ответ: ничего из перечисленного

Объяснение:
Для просмотра параметров конфигурации сервера PostgreSQL используется команда SHOW ALL, которая не входит в список предложенных вариантов. Команда SHOW ALL выводит все настройки конфигурации сервера, включая параметры из файла postgresql.conf.

Предложенные варианты команд psql относятся к другим функциям:

\dc - показывает описания схем
\dconfig - некорректная команда
\dp - показывает привилегии на таблицы
\getenv - некорректная команда
\list - некорректная команда
\pset - устанавливает параметры вывода
Таким образом, среди предложенных вариантов нет команды для просмотра конфигурации сервера.

Анонимный PL/pgSQL блок:
DO $$
DECLARE
l_id integer;
l_descr text;
BEGIN
SELECT t.id, t.descr INTO STRICT l_id, l_descr FROM t;
RAISE NOTICE '%, %', l_id, l_descr;
END;
$$;
Для чего в запросе используется указание STRICT?
Выберите один или несколько ответов:
для гарантии, что количество столбцов в запросе соответствует количеству переменных
для гарантии, что типы данных столбцов t.id, t.descr совпадают с типами данных переменных l_id, l_descr
для гарантии, что ни одной из переменных не будет присвоено пустое значение (NULL)
ничего из перечисленного
Правильные ответы:

для гарантии, что количество столбцов в запросе соответствует количеству переменных
для гарантии, что ни одной из переменных не будет присвоено пустое значение (NULL)
Объяснение:

Ключевое слово STRICT в контексте INTO выполняет две важные функции:
Гарантирует, что количество столбцов в SELECT соответствует количеству переменных
Гарантирует, что запрос вернет ровно одну строку (не NULL)
При использовании STRICT:
Если количество столбцов SELECT не совпадает с количеством переменных - возникнет ошибка
Если запрос вернет 0 строк или NULL - возникнет ошибка
Если запрос вернет более одной строки - также возникнет ошибка
Что касается типов данных:
Соответствие типов данных проверяется всегда, независимо от наличия STRICT
Это базовая проверка PL/pgSQL, которая происходит автоматически
Таким образом, STRICT отвечает за:
Соответствие количества столбцов и переменных
Гарантию получения ровно одной непустой строки
Вариант “ничего из перечисленного” неверный, так как STRICT явно выполняет определенные проверки.

Какие из перечисленных свойств верны для функций на SQL с категорией изменчивости IMMUTABLE?
Предполагается, что категория изменчивости установлена верно.
Выберите один или несколько ответов:
значение функции не зависит ни от чего, кроме значений входных параметров
в пределах запроса значение функции остается постоянным при одних и тех же значениях входных параметров
функция может выдавать разные результаты в одном и том же запросе при одних и тех же значениях входных параметров
если это табличная функция, то ее тело имеет шанс быть подставленным в основной запрос
ничего из перечисленного
Правильные ответы:

значение функции не зависит ни от чего, кроме значений входных параметров
в пределах запроса значение функции остается постоянным при одних и тех же значениях входных параметров
Объяснение:

IMMUTABLE (неизменная) - это самая строгая категория изменчивости функций в PostgreSQL, которая означает:
Функция всегда возвращает одинаковый результат при одинаковых входных параметрах
Результат не зависит от состояния базы данных или внешних факторов
Почему верны выбранные ответы:
“значение функции не зависит ни от чего, кроме значений входных параметров” - это точное определение IMMUTABLE
“в пределах запроса значение функции остается постоянным при одних и тех же значениях входных параметров” - это прямое следствие предыдущего свойства
Почему другие варианты неверны:
“функция может выдавать разные результаты в одном и том же запросе при одних и тех же значениях входных параметров” - противоречит самой сути IMMUTABLE
“если это табличная функция, то ее тело имеет шанс быть подставленным в основной запрос” - это относится к STABLE функциям, а не к IMMUTABLE
“ничего из перечисленного” - неверно, так как первые два варианта являются верными
Таким образом, для IMMUTABLE функций гарантировано, что они всегда возвращают одинаковый результат при одинаковых параметрах и их значение не может меняться в пределах одного запроса при неизменных входных данных.

Каким способом сервер PostgreSQL может взаимодействовать с сеансом подключившегося клиента?
Выберите один или несколько ответов:
обслуживает клиентский сеанс в отдельном потоке основного процесса на сервере
обслуживает клиентский сеанс в отдельном процессе на сервере
обслуживает этот и еще несколько других клиентских сеансов в отдельном процессе на сервере
ничего из перечисленного
Правильные ответы:

обслуживает клиентский сеанс в отдельном процессе на сервере
Объяснение:

PostgreSQL использует модель “один процесс на соединение” (one process per connection):
Каждому клиентскому подключению присваивается отдельный серверный процесс
Этот процесс называется “бэкенд” (backend)
Процесс работает в рамках всего времени сессии клиента
Почему другие варианты неверны:
“обслуживает клиентский сеанс в отдельном потоке основного процесса на сервере” - PostgreSQL не использует многопоточную модель
“обслуживает этот и еще несколько других клиентских сеансов в отдельном процессе на сервере” - каждый процесс обслуживает только одно подключение
“ничего из перечисленного” - неверно, так как первый вариант является правильным
Особенности модели PostgreSQL:
Каждый процесс-бэкенд имеет собственное адресное пространство
Это обеспечивает изоляцию сессий
Упрощает обработку ошибок и восстановление
Снижает риск влияния одного проблемного запроса на другие сессии
Таким образом, сервер PostgreSQL обслуживает каждый клиентский сеанс в отдельном процессе, что является фундаментальным принципом работы этой СУБД.

Для обработки каких событий можно создать триггер уровня оператора (FOR EACH STATEMENT) для таблицы?
Выберите один или несколько ответов:
INSERT
UPDATE
DELETE
TRUNCATE
MERGE
Правильные ответы:

INSERT
UPDATE
DELETE
TRUNCATE
Объяснение:

Триггер уровня оператора (FOR EACH STATEMENT) может быть создан для следующих событий:
INSERT (вставка данных)
UPDATE (обновление данных)
DELETE (удаление данных)
TRUNCATE (очистка таблицы)
Почему эти варианты верны:
Все перечисленные события (кроме MERGE) являются стандартными операциями, на которые можно настроить триггеры
TRUNCATE, несмотря на то, что это команда очистки, также поддерживается как событие для триггера
Почему MERGE не является правильным ответом:
MERGE не является отдельным событием для триггеров в PostgreSQL
В PostgreSQL нет встроенной поддержки MERGE как события для триггеров
Особенности триггеров уровня оператора:
Срабатывают один раз для всего SQL-оператора
Не зависят от количества затронутых строк
Полезны для операций, которые должны выполняться один раз для всей операции
Таким образом, можно создать триггер уровня оператора для обработки событий INSERT, UPDATE, DELETE и TRUNCATE, но не для MERGE.

В сеансе psql при нажатии на «ввод» ничего не происходит. На экране видно:
student/student'# insert into test values ('aaa')
student/student'# insert into test values ('aaa')
student/student'#
Какие дальнейшие действия имеют смысл?
Выберите один или несколько ответов:
нажать Ctrl-C и ввести команду заново
ввести точку с запятой
закрыть терминал и снова запустить psql, чтобы ввести команду заново
ввести команду commit
ввести апостроф
нажать «ввод» несколько раз
Правильные ответы:

ввести точку с запятой
нажать Ctrl-C и ввести команду заново
Объяснение:

В текущей ситуации:
Команда insert into test values ('aaa') не завершена, так как отсутствует точка с запятой
Система ожидает завершения ввода команды
Почему выбраны эти варианты:
Ввод точки с запятой завершит SQL-команду и система сможет её обработать
Нажатие Ctrl-C прервет текущий ввод, позволяя начать ввод команды заново
Почему другие варианты неверны:
“закрыть терминал и снова запустить psql” - не требуется, проблему можно решить проще
“ввести команду commit” - преждевременно, сначала нужно завершить SQL-команду
“ввести апостроф” - неправильно, так как команда уже содержит корректный набор апострофов
“нажать «ввод» несколько раз” - бесполезно, так как система ожидает завершения команды точкой с запятой
Таким образом, для выхода из текущей ситуации достаточно либо завершить команду точкой с запятой, либо прервать ввод с помощью Ctrl-C и начать ввод заново.

CREATE PROCEDURE do_commit() AS
'BEGIN
COMMIT;
END;' LANGUAGE plpgsql;

CREATE FUNCTION f() RETURNS int AS
'BEGIN
CALL do_commit();
RETURN 0;
END;' LANGUAGE plpgsql;
В данном коде есть несколько критических проблем:

В PostgreSQL процедуры (PROCEDURE) появились только с версии 11, поэтому если вы используете более раннюю версию, код вообще не будет работать.
Даже если использовать PostgreSQL 11+, код все равно некорректен по следующим причинам:
COMMIT внутри процедуры/функции может привести к непредсказуемым результатам
CALL statement нельзя использовать внутри функции для вызова процедуры
Использование COMMIT внутри функции вообще не имеет смысла, так как функция выполняется в рамках одного вызова и не может явно завершить транзакцию
Правильный подход:

Использовать только функции (FUNCTION)
Избегать явного COMMIT внутри функций
Если нужна логика, можно использовать вложенные функции
Пример исправленного кода:

CREATE FUNCTION do_commit_safe() RETURNS void AS 
'BEGIN
    -- Здесь лучше оставить код пустым или добавить логирование
    -- COMMIT; -- Не рекомендуется использовать внутри функции
END;' 
LANGUAGE plpgsql;

CREATE FUNCTION f() RETURNS int AS 
'BEGIN
    PERFORM do_commit_safe();
    RETURN 0;
END;' 
LANGUAGE plpgsql;
Важные замечания:

В PostgreSQL лучше использовать PERFORM вместо SELECT при вызове функций без возвращаемого значения
COMMIT должен выполняться на клиенте, а не внутри функций
Все операции внутри функции выполняются в рамках одной транзакции, которую не рекомендуется явно завершать
Такой подход обеспечит более надежное и предсказуемое поведение вашего кода.

Определение процедуры:
CREATE PROCEDURE p(a INOUT int) AS $$
BEGIN
a := 1;
RAISE NOTICE '%', coalesce(a,0);
END;$$ LANGUAGE plpgsql;
Чем закончится выполнение следующего оператора?
CALL p(NULL);
Выберите один ответ:
выполнится успешно, вернет 1
выполнится успешно, вернет 0
завершится ошибкой: нельзя передать константу(NULL) в качестве INOUT параметра
завершится ошибкой: нельзя присвоить константу(1) параметру, переданному константой(NULL)
ничего из перечисленного
Правильный ответ: “выполнится успешно, вернет 1”

Объяснение:

В PostgreSQL параметр INOUT означает, что:
Параметр может быть изменен внутри процедуры
Новое значение может быть возвращено вызывающей стороне
Когда мы передаем NULL как INOUT параметр:
Это абсолютно допустимо
Внутри процедуры мы можем присвоить этому параметру новое значение
В данном случае:
a := 1; корректно присваивает новое значение параметру
RAISE NOTICE выведет текущее значение параметра (1)
Coalesce(a,0) вернет 1, так как a уже присвоено значение 1
Почему другие варианты неверны:
Нельзя передать константу как INOUT параметр - неверно, NULL является допустимым значением
Ошибка при присвоении - неверно, присвоение константы параметру допустимо
Вернет 0 - неверно, так как a уже присвоено значение 1
Таким образом, процедура выполнится успешно и вернет значение 1.

В базе данных созданы следующие функции:
\df
List of functions
Schema | Name | Result data type | Argument data types | Type
--------+------+------------------+------------------------+--------
public | f | integer | real | normal
public | f | integer | integer, INOUT integer | normal
public | f | integer | integer, OUT integer | normal
(3 rows)
Что произойдет при выполнении команды:
CREATE OR REPLACE FUNCTION f(IN integer) RETURNS integer AS ...
При выполнении команды CREATE OR REPLACE FUNCTION f(IN integer) RETURNS integer AS … произойдет следующее:

Будет создана новая функция f с одним входным параметром типа integer. Эта функция не будет конфликтовать с существующими функциями, так как:

Она имеет другую сигнатуру (другое количество параметров) по сравнению с функциями:
f(real)
f(integer, INOUT integer)
f(integer, OUT integer)
PostgreSQL разрешает существование нескольких функций с одинаковыми именами, если их сигнатуры (набор и типы параметров) различаются.
Таким образом, в базе данных появится четвертая версия функции f, которая будет иметь следующую сигнатуру:

f | integer | integer
Это не приведет к удалению или изменению существующих функций, а просто добавит новую перегрузку функции f.

После создания таблицы выполнен анонимный блок:

CREATE TABLE t(id integer);

DO $$
BEGIN
INSERT INTO t(id) VALUES (1);
INSERT INTO t(id) VALUES (2);
RAISE;
EXCEPTION
WHEN others THEN
INSERT INTO t(id) VALUES (3);
END;
$$;
Какое количество строк в таблице вернет запрос:

SELECT count(*) FROM t;
Выберите один ответ:
0
1
2
3
ничего из перечисленного
Правильный ответ: 3

Объяснение:

В блоке DO выполняются следующие операции:
Вставляется запись с ID = 1
Вставляется запись с ID = 2
Команда RAISE генерирует исключение
При возникновении исключения срабатывает блок EXCEPTION
В блоке EXCEPTION вставляется запись с ID = 3
Важно понимать, что:
Все операции в блоке DO происходят в одной транзакции
При возникновении исключения PostgreSQL переходит в блок EXCEPTION
После выполнения блока EXCEPTION транзакция не откатывается
Все предыдущие изменения сохраняются
Таким образом, в таблице t окажутся все три записи:
ID = 1 (первая вставка)
ID = 2 (вторая вставка)
ID = 3 (вставка в блоке EXCEPTION)
Поэтому запрос SELECT count(*) FROM t; вернет значение 3.

Какие форматы pg_dump допускают создание резервной копии параллельно в несколько потоков?

Выберите один или несколько ответов:
plain
custom
directory
tar
ничего из перечисленного
Правильные ответы:

custom
directory
tar
Объяснение:

Формат plain (обычный текстовый формат):
Не поддерживает параллельное дампирование
Создает последовательный SQL-скрипт
Все операции выполняются в одном потоке
Формат custom:
Поддерживает параллельное дампирование
Использует собственный бинарный формат
Может использовать несколько потоков для ускорения процесса
Формат directory:
Создает резервную копию в виде набора файлов в директории
Поддерживает параллельное выполнение
Каждый файл может обрабатываться отдельно
Формат tar:
Создает архив в формате tar
Поддерживает параллельное дампирование
Эффективно использует ресурсы при создании и восстановлении
Таким образом, только форматы custom, directory и tar позволяют выполнять резервное копирование в несколько потоков, что значительно ускоряет процесс для больших баз данных.

При указании неквалифицированного имени таблицы, от чего может зависеть, в какой схеме эта таблица будет найдена?
Выберите один или несколько ответов:
привилегий на схемы
установок локали
привилегий на таблицу
значения параметра search_path
наличия или отсутствия схем с определенными именами
Правильные ответы:

значения параметра search_path
наличия или отсутствия схем с определенными именами
Объяснение:

search_path:
Это ключевой параметр, определяющий порядок поиска объектов
PostgreSQL последовательно проверяет схемы в порядке, указанном в search_path
Первая найденная таблица с подходящим именем будет использована
Наличие схем:
Если в базе существуют схемы с определенными именами
И эти схемы перечислены в search_path
То поиск будет осуществляться именно в этих схемах
Остальные варианты неверны, потому что:
Привилегии на схемы и таблицы влияют только на доступ к объектам
Локаль влияет на правила сортировки и сравнения данных
Они не определяют порядок или место поиска объектов
Таким образом, только search_path и наличие самих схем непосредственно влияют на то, где будет найдена таблица с неквалифицированным именем.

Где располагаются конфигурационные файлы сервера в виртуальной машине курса?
Выберите один или несколько ответов:
/var/log/postgresql
/usr/local/pgsql/data/pg_log
/etc/postgresql/16/main
/usr/local/pgsql/data
/opt/postgres
Правильные ответы:

/etc/postgresql/16/main
/usr/local/pgsql/data
Объяснение:

/etc/postgresql/16/main - это стандартный путь для дистрибутивов, использующих пакетный менеджер (например, apt). Здесь хранятся конфигурационные файлы для версии PostgreSQL 16.
/usr/local/pgsql/data - это типичное расположение для установок из исходников, где находится основной каталог данных с конфигурационными файлами.
Остальные варианты неверны, потому что:

/var/log/postgresql - это каталог для лог-файлов, а не конфигурационных
/usr/local/pgsql/data/pg_log - подкаталог для логов внутри каталога данных
/opt/postgres - нестандартное расположение, которое обычно не используется в типовых установках
В этих директориях находятся основные конфигурационные файлы PostgreSQL:

postgresql.conf
pg_hba.conf
pg_ident.conf
Какие из перечисленных свойств верны для функций на SQL с категорией изменчивости STABLE?
Предполагается, что категория изменчивости установлена верно.
Выберите один или несколько ответов:
значение функции не зависит ни от чего, кроме значений входных параметров
в пределах запроса значение функции остается постоянным при одних и тех же значениях входных параметров
функция может выдавать разные результаты в одном и том же запросе при одних и тех же значениях входных параметров
если это табличная функция, то ее тело имеет шанс быть подставленным в основной запрос
ничего из перечисленного
Правильные ответы:

в пределах запроса значение функции остается постоянным при одних и тех же значениях входных параметров
Объяснение:

STABLE (стабильная) функция:
Гарантирует, что при одинаковых входных параметрах результат будет одинаковым в рамках одного запроса
Может читать данные из базы
Может иметь побочные эффекты
Почему другие варианты неверны:
“значение функции не зависит ни от чего, кроме значений входных параметров” - это характеристика IMMUTABLE функций, а не STABLE
“функция может выдавать разные результаты в одном и том же запросе при одних и тех же значениях входных параметров” - противоречит самой сути STABLE функций
“если это табличная функция, то ее тело имеет шанс быть подставленным в основной запрос” - это относится кInlineable функциям, а не к категории STABLE
Таким образом, ключевым свойством STABLE функций является именно постоянство результата в рамках одного запроса при одинаковых параметрах, что позволяет оптимизатору PostgreSQL делать определенные предположения при планировании запросов.

Из каких слоев (forks) состоят индексы обычных таблиц?

Выберите один или несколько ответов:
основной слой данных
карта видимости
карта свободного пространства
слой инициализации
ничего из перечисленного
Правильные ответы:

основной слой данных
карта свободного пространства
Объяснение:

Основной слой данных:
Всегда присутствует
Содержит сами данные индекса
Это обязательный базовый слой
Карта свободного пространства (FSM):
Существует как для таблиц, так и для индексов
Хранит информацию о свободном месте в страницах
Остальные варианты неверны, потому что:

Карта видимости (VM) существует только для таблиц, для индексов она не применяется
Слой инициализации (init) используется только для нежурналируемых таблиц как пустышка для основного слоя
“Ничего из перечисленного” неверно, так как минимум два слоя всегда присутствуют
Таким образом, индексы обычных таблиц состоят из основного слоя данных и карты свободного пространства, что необходимо для их корректной работы и оптимизации.

CREATE FUNCTION f(p integer) RETURNS SETOF integer STRICT AS ..
Для чего используется указание STRICT в постгрес?
Выберите один или несколько ответов:
возвращаемое значение функции не может быть NULL
если значение параметра NULL, то функция должна сразу вернуть NULL
функция должна вернуть ровно одну строку
тип данных параметра должен соответствовать типу возвращаемого значения
ничего из перечисленного
Правильные ответы:

если значение параметра NULL, то функция должна сразу вернуть NULL
Объяснение:
Опция STRICT в PostgreSQL указывает, что функция должна возвращать NULL, если любой из её аргументов является NULL. Это не означает, что возвращаемое значение функции не может быть NULL в других случаях, а лишь определяет поведение при NULL-аргументах.

Остальные варианты неверны:

Возвращаемое значение может быть NULL, даже если функция объявлена как STRICT
Функция может возвращать любое количество строк, STRICT это не ограничивает
Тип данных параметра и возвращаемого значения могут быть разными
Таким образом, STRICT влияет только на обработку NULL-значений параметров, автоматически возвращая NULL без выполнения тела функции.