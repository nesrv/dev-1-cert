## Вопрос 1 Что делает следующий код в PL/pgSQL?

```sql
FOREACH i IN ARRAY a42 LOOP RAISE LOG '%', i; END LOOP;
```

Выберите один ответ:

- Устанавливает одинаковое значение i для каждого элемента массива a42.
- ! Выводит каждый элемент массива a42 в журнале сообщений сервера
- Получает сумму всех элементов массива a42 и записывает ее в переменную i.
- Итерирует по элементам массива a42, увеличивая каждый из них на единицу.

## Вопрос 2 Какая команда применяется для инициирования ручной очистки всех таблиц базы данных?

Выберите один ответ:

- CLEAN DATABASE
- - VACUUM
- DB_CLEAN
- SWEEP

## Вопрос 3 Какая команда используется для перечитывания конфигурационных файлов без перезапуска сервера?

Выберите один ответ:

- RELOAD POSTGRESQL
- - SELECT pg_reload_conf();
- UPDATE pg_configuration SET reload = true;
- RESTART CONFIGURATION

## Вопрос 4 Какое значение вернет функция?

![alt text](image-4.png)
Выберите один ответ:

- 20
- 22
- - 43
- 42

## Вопрос 5 В какой секции PL/pgSQL обрабатываются исключения?

Выберите один ответ:

- BEGIN
- LOOP
- EXECUTE
- - EXCEPTION
- CATCH

## Вопрос 6 В каком месте хранятся данные системной таблицы pg_database?

Выберите один ответ:

- - pg_global
- pg_default
- pg_system
- pg_catalog
- pg_internal

## Вопрос 7 Какие недостатки связаны с использованием динамических SQL команд в подпрограммах?

Выберите один ответ:

- Увеличение скорости выполнения запросов
- - Потенциальная уязвимость для SQL-инъекций
- Игнорирование ограничения по количеству символов в динамических запросах
- Недоступность использования переменных в динамических SQL командах
- Требуется обязательная компиляция динамических SQL запросов.

Это подтверждается тем, что:

SQL-инъекции являются классической проблемой динамического SQL
Динамический SQL особенно уязвим, когда пользователь передает некорректные или злонамеренные данные
Остальные варианты либо неверны, либо даже являются преимуществами динамического SQL:
Скорость выполнения может даже снижаться из-за проблем с кешированием планов
Ограничения по количеству символов не игнорируются
Переменные можно и нужно использовать в динамических запросах
Компиляция не является обязательным требованием
Поэтому главным недостатком является именно уязвимость к SQL-инъекциям, которую необходимо специально предотвращать правильным использованием инструментов экранирования (например, через FORMAT с %I и %L).

## Вопрос 8 Какая команда служит для отключения режима выравнивания в psql?

Выберите один ответ:

- \p
- - \a
- \h
- \t

Это подтверждается следующим:

Команда \a является переключателем режима выравнивания вывода
Она может включать и выключать выравнивание результатов
\p - это команда для отображения текущего запроса
\h - это команда для получения справки по SQL командам
\t - это команда для включения/выключения отображения заголовков и итоговой строки
Таким образом, именно команда \a отвечает за управление режимом выравнивания вывода в psql.

## Вопрос 9 В режиме изоляции READ COMMITED когда происходит построение снимка данных?

Выберите один ответ:

- Перед началом каждой транзакции
- Перед каждым запросом к таблице
- В момент начала каждой транзакции
- В момент начала чтения каждой строки данных
- - При выполнении каждого оператора транзакции

Это подтверждается тем, что в режиме READ COMMITTED:

Каждый SQL-оператор получает свежий снимок данных

Снимки создаются заново для каждого нового оператора

Это обеспечивает видимость только тех изменений, которые были зафиксированы к моменту выполнения конкретного оператора

В отличие от других режимов изоляции, где снимок может создаваться один раз для всей транзакции

Остальные варианты неверны:

“Перед началом каждой транзакции” - неверно, так как в READ COMMITTED снимок создается чаще

“Перед каждым запросом к таблице” - некорректная формулировка

“В момент начала каждой транзакции” - неверно для READ COMMITTED

“В момент начала чтения каждой строки данных” - слишком часто и не соответствует механизму работы

Таким образом, именно выполнение каждого оператора является триггером для создания нового снимка данных в режиме READ COMMITTED.

## Вопрос 10 Какой способ можно использовать для удаления базы данных с отключением всех клиентов?

Выберите один ответ:

- - DROP DATABASE D1 WITH (FORCE);
- DROP DATABASE IF EXISTS D1;
- ALTER DATABASE D1 SET SINGLE_USER WITH ROLLBACK IMMEDIATE; DROP DATABASE D1;
- Использовать команду KILL для отключения клиентов, а затем удалить базу данных;
- Переименовать базу данных, создать новую и скопировать данные.

Это подтверждается следующими фактами:

Опция WITH (FORCE) специально предназначена для “силового” удаления базы данных

Она доступна начиная с PostgreSQL версии 13

Автоматически принудительно закрывает все активные сеансы

Позволяет выполнить удаление даже при подключенных клиентах

Остальные варианты неверны:

DROP DATABASE IF EXISTS D1 только проверяет существование БД, но не отключает клиентов

ALTER DATABASE … SET SINGLE_USER требует дополнительных действий

Использование KILL требует ручного отслеживания всех подключений

Переименование и копирование - это сложный и избыточный способ, который не гарантирует корректного удаления

Таким образом, DROP DATABASE WITH (FORCE) является наиболее эффективным и безопасным способом удаления базы данных с автоматическим отключением всех клиентов.

## Вопрос 11 Какие шаги необходимо предпринять для создания триггеров для обработки команды MERGE?

Выберите один ответ:

- - Создать триггеры для вставки, обновления и удаления данных
- Использовать выражение CASE для обработки команды MERGE внутри триггера
- Использовать механизм транзакций для согласованности данных при выполнении MERGE
- Разработать хранимую процедуру для реализации функциональности MERGE

Это подтверждается следующими фактами:

Команда MERGE фактически объединяет в себе операции INSERT, UPDATE и DELETE

Для обработки MERGE необходимо создать триггеры для каждой из этих операций

Это позволяет корректно обрабатывать все аспекты команды MERGE

Остальные варианты неверны:

Использование CASE внутри триггера не является правильным подходом для обработки MERGE

Механизм транзакций важен для согласованности, но это не специфический шаг для создания триггеров

Разрабатывание хранимой процедуры не является необходимым для обработки MERGE через триггеры

Таким образом, для корректной обработки команды MERGE через триггеры необходимо создать отдельные триггеры для операций вставки, обновления и удаления данных.

## Вопрос 12 Какая команда используется для получения информации о текущем подключении в psql?

Выберите один ответ:

- \cinfo
- \conn
- \connect
- - \conninfo

Это подтверждается следующими фактами:

Команда \conninfo специально предназначена для вывода информации о текущем подключении

Она показывает детали подключения, такие как:

имя базы данных

имя пользователя

способ подключения (через сокет или сеть)

номер порта

Остальные варианты неверны:

\cinfo - такой команды не существует

\conn - такой команды не существует

\connect (или \c) используется для установления нового подключения, а не для получения информации о текущем

Например, вывод команды может выглядеть так:

You are connected to database "student" as user "student" via socket in "/var/run/postgresql" at port "5432

## Вопрос 13 Каким образом можно заполнить одномерный массив в PL/pgSQL?

Выберите один ответ:

- + С помощью оператора ARRAY
- Используя функцию CREATEARRAY()
- При помощи ключевого слова FILLARRAY()
- Через использование оператора INSERT INTO

Правильный ответ: С помощью оператора ARRAY

В PL/pgSQL для создания массива используется синтаксис ARRAY[]

Пример использования: ARRAY[1,2,3,4]

Это стандартный и рекомендуемый способ создания массивов

Остальные варианты неверны:

Функции CREATEARRAY() не существует в PL/pgSQL

Ключевого слова FILLARRAY() также не существует

Оператор INSERT INTO используется для вставки данных в таблицы, а не для создания массивов

Дополнительно стоит отметить, что можно использовать и другой способ записи - через фигурные скобки: '{значение1,значение2,значение3}'

Пример создания одномерного массива в PL/pgSQL:

```sql
DECLARE
  my_array integer[];
BEGIN
  my_array := ARRAY[10, 20, 30, 40];
  -- или альтернативный способ
  my_array := '{10,20,30,40}';
END;
```

## Вопрос 14 Какие типы изменчивости функций используются в PL/pgSQL?

Выберите несколько ответов:

* + STABLE
* + IMMUTABLE
* CALLED ONCE
* + VOLATILE
* LEAKPROOF
* CALM


Это подтверждается следующими фактами:

VOLATILE - функция может возвращать разные результаты при одинаковых аргументах и может модифицировать базу данных

STABLE - функция гарантирует одинаковый результат при одинаковых аргументах в рамках одного оператора и не может модифицировать базу данных

IMMUTABLE - функция всегда возвращает одинаковый результат при одинаковых аргументах и не может модифицировать базу данных



## Вопрос 15 Опишите процедуру передачи курсора клиенту в PL/pgSQL. Какие шаги включены в этот процесс и каковы его потенциальные применения?

Выберите один ответ:

* Курсоры не могут быть переданы клиенту; они всегда используются исключительно внутри сервера для управления данными.
* Курсор открывается в PL/pgSQL и передается клиенту только для чтения данных, без возможности выполнения операций записи или обновления.
* Клиент может выполнять операции чтения курсора, но не управление транзакциями.
* + Функция на PL/pgSQL открывает курсор и возвращает его имя клиенту, который может управлять данными курсора, включая чтение и обновление


Это подтверждается следующими фактами:

PL/pgSQL позволяет создавать функции, которые:

Открывают курсор

Возвращают его идентификатор

Клиент может работать с этим курсором

Клиент может выполнять:

Операции чтения

Операции обновления данных через курсор

Управление перемещением по набору данных

Потенциальные применения:

Обработка больших наборов данных
Последовательная обработка записей
Интерактивное взаимодействие с базой данных
Обновление данных построчно
Пример реализации:

```SQL
CREATE FUNCTION get_cursor() RETURNS refcursor AS $$
DECLARE
    my_cursor refcursor;
BEGIN
    OPEN my_cursor FOR SELECT * FROM my_table;
    RETURN my_cursor;
END;
$$ LANGUAGE plpgsql;

--После получения курсора клиент может выполнять:

FETCH FROM get_cursor();
UPDATE my_table SET column = value WHERE CURRENT OF get_cursor;
```

Такой подход особенно полезен при работе с большими наборами данных, когда необходимо:

Обрабатывать данные порциями

Выполнять сложные операции обновления

Обеспечивать последовательный доступ к данным





## Вопрос 16 Какой уровень изоляции гарантирует, что каждый последующий запрос в транзакции будет видеть данные, согласованные на момент начала транзакции?

Выберите один ответ:

* Read Uncommitted
* Read Committed
* Serializable
* + Repeatable Read


Это подтверждается следующими фактами:

Repeatable Read гарантирует, что:

Транзакция видит “снимок” данных на момент начала транзакции

Все запросы внутри транзакции видят одни и те же данные

Данные остаются согласованными на момент начала транзакции

Пример работы Repeatable Read:
```SQL
-- Сессия 1 (Repeatable Read)
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT balance FROM bank_accounts WHERE id = 1; -- Предположим, баланс 1000

-- В это время другая сессия меняет данные
-- Сессия 2
UPDATE bank_accounts SET balance = balance + 500 WHERE id = 1;
COMMIT;

-- Но в первой сессии мы всё ещё видим старое значение
-- Сессия 1
SELECT balance FROM bank_accounts WHERE id = 1; -- Всё еще видит 1000
COMMIT;
```

Другие варианты неверны, потому что:

Read Uncommitted видит незафиксированные изменения других транзакций
Read Committed может видеть новые изменения после каждого запроса
Serializable хотя и обеспечивает строгую изоляцию, но фокусируется на последовательном выполнении транзакций, а не на согласованности данных на момент начала
Этот уровень изоляции особенно важен для:

Операций, требующих согласованности данных
Сложных аналитических запросов
Процедур, где важна целостность данных на протяжении всей транзакции



## Вопрос 17 Какой из следующих уровней изоляции не поддерживается в PostgreSQL?

Выберите один ответ:

* READ COMMITTED
* REPEATABLE READ
* SERIALIZABLE
* + READ UNCOMMITTED


Это подтверждается следующими фактами:

В PostgreSQL поддерживаются только три уровня изоляции:

READ COMMITTED (уровень по умолчанию)

REPEATABLE READ

SERIALIZABLE

READ UNCOMMITTED намеренно не реализован в PostgreSQL, потому что:

Он может привести к чтению “грязных” данных

Создает риски для целостности данных

Не соответствует философии надежности PostgreSQL

PostgreSQL обеспечивает:

Безопасное чтение только подтвержденных данных

Консистентность данных при повторном чтении (REPEATABLE READ)

Полную сериализуемость операций (SERIALIZABLE)

Это важное отличие PostgreSQL от других СУБД, где READ UNCOMMITTED может быть доступен как самый слабый уровень изоляции.

Пример установки уровня изоляции в PostgreSQL:

BEGIN ISOLATION LEVEL REPEATABLE READ;
-- или
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

READ UNCOMMITTED часто используется в системах, где требуется максимальная производительность ценой потенциальной несогласованности данных, но такой компромисс противоречит философии PostgreSQL, ориентированной на надежность и целостность данных.



## Вопрос 18 Как можно подключиться к базе данных template1 сразу после установки и инициализации кластера БД от имени обычного пользователя?

Выберите один ответ:

* psql template1
* + sudo psql -d template1
* useradd -d template1 -U postgres
* psql -c 'CREATE DATABASE test' template1

Это подтверждается следующими фактами:

Сразу после установки кластера БД:

Только пользователь postgres или root имеют доступ к базе template1

Обычный пользователь не имеет прав на доступ к template1

Команда sudo psql -d template1:

Выполняется с правами суперпользователя

Позволяет подключиться к базе template1

Соответствует требованиям безопасности

Другие варианты неверны, потому что:

psql template1 - не сработает без прав суперпользователя

useradd -d template1 -U postgres - это некорректная команда для подключения

psql -c ‘CREATE DATABASE test’ template1 - попытка создания БД без нужных прав

Важно отметить, что template1 является системной базой данных, которая используется как шаблон для создания новых баз данных. 

Прямой доступ к ней обычно ограничен по соображениям безопасности и целостности данных.

После инициализации кластера рекомендуется создать отдельного пользователя с нужными правами для работы с базами данных, вместо постоянного использования суперпользовательского доступа.



## Вопрос 19 Какие характеристики роли pg_database_owner следует учитывать?

Выберите один ответ:

* В нее можно включить внешнюю учетную запись
* Она не может управлять объектами и получать права доступа
* В нее можно включить другие роли явно
* + BНельзя добавить роль pg_database_owner явно в другую роль

pg_database_owner - это специальная роль в PostgreSQL, которая:

Назначается автоматически при создании базы данных

Содержит владельцев всех баз данных

Является системной встроенной ролью

Особенности роли pg_database_owner:

Не может быть явно добавлена в другие роли

Является группой для всех владельцев баз данных

Предоставляет права на управление базами данных

Почему другие варианты неверны:

Внешнюю учетную запись нельзя включить напрямую

Роль может управлять объектами в рамках своих баз данных

Нельзя явно включать другие роли в pg_database_owner

Практическое применение:

Используется системой для определения владельцев баз данных

Помогает в управлении правами доступа к базам данных

Обеспечивает безопасность через ограничение возможностей

Это важный аспект безопасности PostgreSQL, который помогает контролировать доступ к базам данных и предотвращает случайное или намеренное нарушение целостности системы.

Рекомендуется использовать эту роль только для системных целей и не пытаться модифицировать её состав вручную.



## Вопрос 20 Какую характеристику курсорной переменной в PL/pgSQL нужно учитывать при их объявлении и использовании?


* + Имя курсора должно быть уникальным
* Курсоры не могут использоваться внутри транзакций
* Каждому курсору обязательно нужно задать тип данных
* По умолчанию курсоры открываются в режиме автокоммит
* Курсоры не могут быть объявлены внутри циклов.

П
Это подтверждается следующими фактами:

Все порталы (курсоры) должны иметь уникальные имена в пределах сессии.

PL/pgSQL автоматически присваивает уникальные имена порталам, если не указано иное.

При присвоении курсорной переменной ненулевого строкового значения, эта строка используется как имя портала.

Другие варианты неверны, потому что:

Курсоры могут использоваться внутри транзакций (на самом деле они автоматически закрываются при завершении транзакции)

Тип данных для курсора всегда один - refcursor

Курсоры не открываются в режиме автокоммит

Курсоры могут быть объявлены внутри циклов

Практическое применение:

```SQL
DECLARE
  curs1 refcursor; -- автоматически получит уникальное имя
  curs2 refcursor; -- должно быть уникальным
BEGIN
  OPEN curs1 FOR SELECT * FROM table;
  -- ...
END;
```
Это важное ограничение для обеспечения корректной работы с курсорами, так как уникальные имена позволяют однозначно идентифицировать каждый портал в рамках сессии.



## Вопрос 21 Как можно сделать составной типа данных?

* + С помощью оператора CREATE TYPE.
* С использованием ключевого слова COMPOSITE
* С помощью ключевого слова STRUCT
* Используя ключевое слово ARRAY
* С использованием функции DEFINE_TYPE
* Используя ключевое слово UNION

Это подтверждается следующими фактами:

Синтаксис создания составного типа данных:
```SQL
CREATE TYPE имя_типа AS (
    поле1 тип_данных,
    поле2 тип_данных
);
Пример создания:
CREATE TYPE product_type AS (
    kod integer,
    name character varying(100)
);


```
Другие варианты неверны, потому что:

COMPOSITE используется как тип в pgAdmin при создании через интерфейс

STRUCT не является ключевым словом в PostgreSQL

ARRAY - это отдельный тип данных, не связанный с составными типами

DEFINE_TYPE не существует в PostgreSQL

UNION используется для объединения результатов запросов
Составной тип данных можно использовать после создания как любой другой тип данных, например, при создании таблиц:

```SQL
CREATE TABLE products (
    id INT PRIMARY KEY,
    type product_type
);

```
Это стандартный и рекомендуемый способ работы с составными типами данных в PostgreSQL.


## Вопрос 22 Какая функция возвращает текущее значение счетчика транзакций?



* + pg_current_xact_id();
* retrieve_current_count()
* counter_clog()
* nextval()
* current_value_xact()

pg_current_xact_id() - это системная функция PostgreSQL, которая:

Возвращает текущий ID транзакции

Возвращает значение типа xid8

Добавлена в PostgreSQL 13

Заменяет функцию txid_current()

Пример использования:

SELECT pg_current_xact_id();

Другие варианты неверны, потому что:

retrieve_current_count() - несуществующая функция

counter_clog() - несуществующая функция

nextval() - функция для работы с последовательностями

current_value_xact() - несуществующая функция

Важно отметить, что если текущая транзакция еще не имеет ID, функция pg_current_xact_id() присвоит новый ID. 

Для получения ID только если он уже назначен, следует использовать pg_current_xact_id_if_assigned().

Эта функция часто используется для:

Отслеживания порядка транзакций

Отладки проблем с параллелизмом

Получения информации о состоянии базы данных



## Вопрос 23 Какая команда может быть использована для загрузки данных из текстового файла в таблицу, если учитывается заголовок данных в файле?


* COPY (TRUE)
* IMPORT (HEADER MATCH)
* LOAD (HEADERS)
* INSERT INTO (HEADER IS TRUE)
* + COPY (HEADER MATCH)


Это подтверждается следующими фактами:

Команда COPY поддерживает параметр HEADER, который указывает, что первая строка файла содержит заголовки столбцов:

COPY my_table FROM '/path/to/file.csv' DELIMITER ',' CSV HEADER;

В синтаксисе COPY есть опция HEADER, которая:

Пропускает первую строку файла

Использует имена столбцов из первой строки

Соответствует заголовкам таблицы

Другие варианты неверны, потому что:


COPY (TRUE) - некорректный синтаксис
IMPORT (HEADER MATCH) - нет такой команды в PostgreSQL
LOAD (HEADERS) - нет такой команды в PostgreSQL
INSERT INTO (HEADER IS TRUE) - некорректный синтаксис

Практический пример использования:
```SQL
-- Создание таблицы
CREATE TABLE employees (
    id serial PRIMARY KEY,
    name text,
    department text
);

-- Загрузка данных из CSV с заголовком
COPY employees FROM '/path/to/employees.csv'
DELIMITER ','
CSV HEADER;
```

Это стандартный и рекомендуемый способ загрузки данных из файлов с заголовками в PostgreSQL.



## Вопрос 24 Какую команду необходимо использовать для создания нового пользователя?

Выберите один ответ:

* + CREATE ROLE
* INSERT USER
* REGISTER USER
* ADD USER
* NEW USER

CREATE ROLE - это стандартная команда PostgreSQL для создания пользователей и ролей:

CREATE ROLE имя_пользователя [WITH параметры];

Команда позволяет задать различные параметры:

LOGIN (право на подключение)

SUPERUSER (права суперпользователя)

CREATEDB (право создавать базы данных)

PASSWORD (пароль пользователя)

Пример создания пользователя:
```SQL
CREATE ROLE new_user WITH
    LOGIN
    PASSWORD 'password'
    CREATEDB
    NOSUPERUSER;
```

Другие варианты неверны, потому что:

INSERT USER - некорректный синтаксис

REGISTER USER - нет такой команды

ADD USER - нет такой команды

NEW USER - нет такой команды

CREATE ROLE является рекомендуемым и единственным корректным способом создания 
пользователей в PostgreSQL. Эта команда также позволяет управлять правами и привилегиями новых пользователей.


## Вопрос 25 Какой уровень изоляции является установленным по умолчанию в PostgreSQL?

Выберите один ответ:

* SERIALIZABLE
* REPEATABLE READ
* * READ COMMITTED
* READ UNCOMMITTED
* AUTOCOMMIT



READ COMMITTED - это уровень изоляции по умолчанию в PostgreSQL
Этот уровень гарантирует, что:

Любая прочитанная данные должна быть уже зафиксирована (committed)
Предотвращаются грязные чтения (dirty reads)

Однако возможны неповторяющиеся чтения (non-repeatable reads) и фантомные чтения (phantom reads)

Пример использования:
```SQL
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM orders WHERE amount > 100;
COMMIT;
```

Другие варианты неверны, потому что:

READ UNCOMMITTED вообще не поддерживается PostgreSQL

REPEATABLE READ, SERIALIZABLE и AUTOCOMMIT - это другие уровни изоляции, но они не являются уровнями по умолчанию

Важно отметить, что READ COMMITTED обеспечивает хороший баланс между:

Согласованностью данных

Производительностью

Параллелизмом выполнения транзакций

Этот уровень изоляции гарантирует, что даже если другие транзакции модифицируют данные, каждое утверждение внутри вашей транзакции увидит консистентное состояние зафиксированных данных на момент начала выполнения.


## Вопрос 26 Какую конструкцию следует использовать для написания функции в стиле стандарта SQL, содержащей несколько SQL операторов?

Выберите один ответ:

* RETURN
* BEGIN ... END
* USING SQL
* STYLED AS SQL STANDARD
* + BEGIN ATOMIC ... END

Это подтверждается следующими фактами:

Конструкция BEGIN ATOMIC … END:

Соответствует стандарту SQL

Позволяет группировать несколько SQL операторов

Обеспечивает атомарность выполнения блока

Поддерживается в различных СУБД

Пример использования:

```SQL
CREATE FUNCTION my_function()
RETURNS INTEGER
LANGUAGE SQL
BEGIN ATOMIC
    DECLARE var INTEGER;
    SELECT column INTO var FROM my_table;
    RETURN var;
END
```

Другие варианты неверны, потому что:

* RETURN - это только команда для возврата значения из функции

* BEGIN … END - используется в T-SQL, но не соответствует стандарту SQL

* USING SQL - некорректная конструкция

* STYLED AS SQL STANDARD - не существует такой конструкции

Важно отметить, что конструкция BEGIN ATOMIC … END:

Обеспечивает выполнение всех операторов как единой атомарной операции

Поддерживает обработку ошибок

Соответствует стандартам ANSI SQL

Гарантирует, что либо все операторы выполнятся успешно, либо ни один не вступит в силу



## Вопрос 27 Какой параметр позволяет автоматически находить таблицу в нужной схеме при обращении к ней по короткому имени?

Выберите один ответ:

* searchschema
* autoschema
* * searchpath
* schemapath


Это подтверждается следующими фактами:

search_path - это параметр, который определяет путь поиска объектов в PostgreSQL

По умолчанию search_path установлен как:

search_path = "$user", public

При обращении к таблице без указания схемы PostgreSQL:

Сначала ищет таблицу в первой схеме из search_path

Если не находит, ищет во второй схеме

И так далее по порядку

Можно изменить search_path командой:

SET search_path = public, имя_схемы;

Реальный путь поиска можно посмотреть командой:

SELECT current_schemas(true);

Другие варианты неверны, потому что:


searchschema, autoschema и schemapath - это несуществующие параметры в PostgreSQL
Важно отметить, что:

Если схема не существует или у пользователя нет к ней доступа, она будет исключена из пути поиска
Всегда есть неявное добавление схемы pg_catalog в путь поиска
Порядок схем в search_path важен для определения приоритета поиска



![alt text](image-5.png)

## Вопрос 2
На изображении представлены варианты ответа на вопрос о том, какой термин используется для указания раздела переменных в PL/pgSQL. Согласно предоставленной информации, правильный ответ — DECLARE.
```
