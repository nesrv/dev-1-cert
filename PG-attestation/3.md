

## Операции INSERT, UPDATE и DELETE с помощью оператора "MERGE". Синтаксис и основные элементы


# Использование оператора MERGE в PostgreSQL для INSERT, UPDATE и DELETE

Оператор MERGE (также известный как "upsert") в PostgreSQL позволяет выполнять операции INSERT, UPDATE и DELETE в одном выражении, что очень удобно для синхронизации данных между таблицами.

## Основной синтаксис MERGE

```sql
MERGE INTO target_table USING source_table
ON merge_condition
WHEN MATCHED THEN
    UPDATE SET column1 = value1, column2 = value2, ...
    [DELETE WHERE condition]
WHEN NOT MATCHED THEN
    INSERT (column1, column2, ...) VALUES (value1, value2, ...);
```

## Примеры использования

### 1. Базовый пример с INSERT и UPDATE

```sql
-- Создаем тестовые таблицы
CREATE TABLE target_products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    price DECIMAL(10, 2),
    quantity INT
);

CREATE TABLE source_products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    price DECIMAL(10, 2),
    quantity INT
);

-- Вставляем начальные данные
INSERT INTO target_products VALUES 
(1, 'Laptop', 999.99, 10),
(2, 'Phone', 499.99, 20);

INSERT INTO source_products VALUES 
(1, 'Laptop', 899.99, 15), -- Обновим цену и количество
(3, 'Tablet', 299.99, 30); -- Новый товар

-- Выполняем MERGE
MERGE INTO target_products t
USING source_products s
ON t.product_id = s.product_id
WHEN MATCHED THEN
    UPDATE SET 
        product_name = s.product_name,
        price = s.price,
        quantity = s.quantity
WHEN NOT MATCHED THEN
    INSERT (product_id, product_name, price, quantity)
    VALUES (s.product_id, s.product_name, s.price, s.quantity);
```

### 2. Пример с DELETE условием

```sql
-- Добавим условие для удаления
MERGE INTO target_products t
USING source_products s
ON t.product_id = s.product_id
WHEN MATCHED AND s.quantity = 0 THEN
    DELETE
WHEN MATCHED THEN
    UPDATE SET 
        product_name = s.product_name,
        price = s.price,
        quantity = s.quantity
WHEN NOT MATCHED THEN
    INSERT (product_id, product_name, price, quantity)
    VALUES (s.product_id, s.product_name, s.price, s.quantity);
```

### 3. Пример с подзапросом в качестве источника

```sql
-- MERGE с подзапросом вместо таблицы
MERGE INTO target_products t
USING (
    SELECT product_id, product_name, price, quantity 
    FROM source_products 
    WHERE price > 300
) s
ON t.product_id = s.product_id
WHEN MATCHED THEN
    UPDATE SET 
        product_name = s.product_name,
        price = s.price,
        quantity = s.quantity
WHEN NOT MATCHED THEN
    INSERT (product_id, product_name, price, quantity)
    VALUES (s.product_id, s.product_name, s.price, s.quantity);
```

### 4. Пример с несколькими условиями

```sql
MERGE INTO target_products t
USING source_products s
ON t.product_id = s.product_id
WHEN MATCHED AND t.price > s.price THEN
    UPDATE SET price = s.price -- Обновляем только если цена в источнике ниже
WHEN MATCHED AND t.price <= s.price THEN
    DO NOTHING -- Ничего не делаем, если цена в источнике выше или равна
WHEN NOT MATCHED THEN
    INSERT (product_id, product_name, price, quantity)
    VALUES (s.product_id, s.product_name, s.price, s.quantity);
```

## Важные заметки

1. Оператор MERGE был добавлен в PostgreSQL начиная с версии 15.
2. MERGE выполняется как единая атомарная операция.
3. Можно использовать несколько WHEN MATCHED и WHEN NOT MATCHED условий, но порядок имеет значение.
4. Для более старых версий PostgreSQL можно использовать INSERT ... ON CONFLICT (UPSERT) для аналогичной функциональности.

MERGE особенно полезен при:
- Синхронизации таблиц
- Пакетных обновлениях данных
- Реализации сложной бизнес-логики обновлений


## Операторы ветвления логики. "DECODE", "CASE WHEN"(2 способа). Синтаксис и основные элементы.

# Операторы ветвления логики в PostgreSQL

PostgreSQL предоставляет несколько операторов для ветвления логики в SQL-запросах. Рассмотрим основные из них: DECODE и CASE WHEN (в двух вариантах).

## 1. DECODE

DECODE - это функция, аналогичная CASE WHEN, но с другим синтаксисом (унаследована из Oracle).

### Синтаксис:
```sql
DECODE(выражение, значение1, результат1, 
                   значение2, результат2, 
                   ...
                   значениеN, результатN, 
                   default_результат)
```

### Пример:
```sql
SELECT product_name, 
       DECODE(category_id, 1, 'Electronics', 
                           2, 'Clothing', 
                           3, 'Food', 
                           'Other') AS category_name
FROM products;
```

## 2. CASE WHEN (два варианта)

### Вариант 1: Простое CASE выражение

Аналогично DECODE, но с другим синтаксисом.

#### Синтаксис:
```sql
CASE выражение
    WHEN значение1 THEN результат1
    WHEN значение2 THEN результат2
    ...
    WHEN значениеN THEN результатN
    ELSE default_результат
END
```

#### Пример:
```sql
SELECT product_name, 
       CASE category_id
           WHEN 1 THEN 'Electronics'
           WHEN 2 THEN 'Clothing'
           WHEN 3 THEN 'Food'
           ELSE 'Other'
       END AS category_name
FROM products;
```

### Вариант 2: Поисковое CASE выражение

Более гибкий вариант, позволяющий использовать условия.

#### Синтаксис:
```sql
CASE
    WHEN условие1 THEN результат1
    WHEN условие2 THEN результат2
    ...
    WHEN условиеN THEN результатN
    ELSE default_результат
END
```

#### Пример:
```sql
SELECT product_name, price,
       CASE
           WHEN price < 100 THEN 'Cheap'
           WHEN price >= 100 AND price < 500 THEN 'Medium'
           WHEN price >= 500 THEN 'Expensive'
           ELSE 'Not priced'
       END AS price_category
FROM products;
```

## Основные элементы:

1. **Выражение/условие** - то, что оценивается для выбора ветви
2. **THEN** - определяет результат при выполнении условия
3. **ELSE** - необязательный элемент, определяющий результат по умолчанию
4. **END** - обязательное завершение CASE выражения

## Особенности в PostgreSQL:

- DECODE не является стандартной функцией SQL, но доступна в PostgreSQL через расширение oracle_fdw
- CASE WHEN является стандартным SQL и предпочтительнее для использования
- CASE выражения могут использоваться в SELECT, WHERE, GROUP BY, ORDER BY и других частях запроса
- Можно вкладывать CASE выражения друг в друга для сложной логики




# Иерархические запросы в PostgreSQL с использованием WITH RECURSIVE

В PostgreSQL для работы с иерархическими данными (деревьями, графами) используется конструкция `WITH RECURSIVE` в сочетании с `UNION ALL`. Это мощный инструмент для обработки рекурсивных структур данных.

## Базовый синтаксис

```sql
WITH RECURSIVE recursive_query_name AS (
    -- Не рекурсивная часть (начальное условие)
    SELECT initial_columns
    FROM initial_table
    WHERE initial_condition
    
    UNION ALL
    
    -- Рекурсивная часть
    SELECT recursive_columns
    FROM recursive_table
    JOIN recursive_query_name ON join_condition
    WHERE recursive_condition
)
SELECT * FROM recursive_query_name;
```

## Основные компоненты

1. **Не рекурсивная часть** - определяет начальные строки (корни дерева)
2. **UNION ALL** - объединяет результаты
3. **Рекурсивная часть** - ссылается на сам запрос, строя иерархию

## Пример 1: Иерархия сотрудников

Допустим, есть таблица employees с полями id, name и manager_id:

```sql
WITH RECURSIVE employee_hierarchy AS (
    -- Базовый случай: начальники (у которых нет менеджера)
    SELECT id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Рекурсивный случай: подчиненные
    SELECT e.id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.id
)
SELECT id, name, level FROM employee_hierarchy
ORDER BY level, name;
```

## Пример 2: Дерево категорий

Для таблицы categories с полями id, name, parent_id:

```sql
WITH RECURSIVE category_tree AS (
    -- Базовый случай: корневые категории
    SELECT id, name, parent_id, ARRAY[name] AS path
    FROM categories
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- Рекурсивный случай: дочерние категории
    SELECT c.id, c.name, c.parent_id, ct.path || c.name
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT id, name, array_to_string(path, ' > ') AS full_path
FROM category_tree
ORDER BY path;
```

## Пример 3: Поиск путей в графе

Для таблицы graph с полями source, target, weight:

```sql
WITH RECURSIVE paths AS (
    -- Базовый случай: пути длиной 1
    SELECT source, target, weight, ARRAY[source, target] AS path
    FROM graph
    
    UNION ALL
    
    -- Рекурсивный случай: удлинение путей
    SELECT p.source, g.target, p.weight + g.weight, p.path || g.target
    FROM paths p
    JOIN graph g ON p.target = g.source
    WHERE NOT g.target = ANY(p.path) -- избегаем циклов
)
SELECT * FROM paths
WHERE source = 1 AND target = 5
ORDER BY weight;
```

## Важные особенности

1. **Условие остановки** - рекурсия прекращается, когда рекурсивная часть не возвращает строк
2. **Предотвращение циклов** - важно добавить проверку (как в примере 3)
3. **Глубина рекурсии** - PostgreSQL имеет лимит (по умолчанию 100), который можно изменить: `SET max_recursive_iterations TO 500;`

## Оптимизация производительности

1. Используйте индексы на соединяемых столбцах
2. Добавляйте условия WHERE в рекурсивную часть для ранней фильтрации
3. Для больших иерархий рассмотрите материализацию промежуточных результатов

Рекурсивные запросы - мощный инструмент для работы с иерархическими данными, который позволяет решать сложные задачи средствами SQL.


# Рекурсивный факториал

```sql
WITH RECURSIVE t(n,factorial) AS (
  VALUES (0,1)
  UNION ALL
  SELECT t.n+1, t.factorial*(t.n+1) FROM t WHERE t.n < 10
)
SELECT * FROM t;
```

# Рекурсивный фибоначи
```sql
WITH RECURSIVE fibonacci(n, fib_n, next_fib) AS (
    -- Базовый случай: первые два числа Фибоначчи
    SELECT 1, 0, 1    
    UNION ALL       
    SELECT n + 1, next_fib, fib_n + next_fib
    FROM fibonacci
    WHERE n < 20 -- Ограничиваем количество итераций
)
SELECT n, fib_n AS fibonacci_number
FROM fibonacci
ORDER BY n;
```


# Примеры использования функции `LEAD()` в PostgreSQL

Функция `LEAD()` - это оконная функция, которая позволяет получить значение из следующей строки в наборе результатов без использования самосоединения. Вот несколько практических примеров:

## 1. Базовый пример с числами

```sql
SELECT 
    num,
    LEAD(num) OVER (ORDER BY num) AS next_num
FROM (VALUES (1), (5), (10), (15)) AS t(num);
```

Результат:
```
 num | next_num
-----+----------
   1 |        5
   5 |       10
  10 |       15
  15 |     NULL
```

## 2. Сравнение текущей и следующей даты

```sql
SELECT 
    employee_id,
    event_date,
    LEAD(event_date) OVER (PARTITION BY employee_id ORDER BY event_date) AS next_event_date
FROM employee_events;
```

## 3. Расчет разницы между текущим и следующим значением

```sql
SELECT 
    product_id,
    price_date,
    price,
    LEAD(price) OVER (PARTITION BY product_id ORDER BY price_date) AS next_price,
    LEAD(price) OVER (PARTITION BY product_id ORDER BY price_date) - price AS price_change
FROM product_prices;
```

## 4. Использование с параметрами (offset и default)

```sql
SELECT 
    month,
    revenue,
    LEAD(revenue, 2, 0) OVER (ORDER BY month) AS revenue_two_months_later
FROM monthly_sales;
```

## 5. Анализ последовательности действий пользователя

```sql
SELECT 
    user_id,
    action,
    action_time,
    LEAD(action) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action,
    LEAD(action_time) OVER (PARTITION BY user_id ORDER BY action_time) - action_time AS time_to_next_action
FROM user_actions;
```

## 6. Нахождение следующей более высокой зарплаты в отделе

```sql
SELECT 
    department,
    employee_name,
    salary,
    LEAD(salary) OVER (PARTITION BY department ORDER BY salary DESC) AS next_higher_salary
FROM employees;
```

## 7. Анализ временных промежутков между заказами

```sql
SELECT 
    customer_id,
    order_date,
    LEAD(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) AS next_order_date,
    AGE(LEAD(order_date) OVER (PARTITION BY customer_id ORDER BY order_date), order_date) AS days_between_orders
FROM orders;
```

Функция `LEAD()` особенно полезна, когда вам нужно сравнить текущую строку со следующей строкой в определенном порядке, что часто требуется при анализе временных рядов, последовательностей событий или изменений значений во времени.

# Создание таблицы `employee_events` и заполнение тестовыми данными

Вот SQL-код для создания таблицы и заполнения ее данными, которые можно использовать для демонстрации работы функции `LEAD()`:

```sql
-- Создаем таблицу employee_events
CREATE TABLE employee_events (
    event_id SERIAL PRIMARY KEY,
    employee_id INTEGER NOT NULL,
    event_name VARCHAR(100),
    event_date DATE NOT NULL
);

-- Заполняем таблицу тестовыми данными
INSERT INTO employee_events (employee_id, event_name, event_date) VALUES
-- События для сотрудника 101
(101, 'Начало работы', '2023-01-10'),
(101, 'Повышение', '2023-04-15'),
(101, 'Перевод в другой отдел', '2023-08-20'),
(101, 'Окончание работы', '2023-12-05'),

-- События для сотрудника 102
(102, 'Начало работы', '2023-02-01'),
(102, 'Обучение', '2023-03-10'),
(102, 'Больничный', '2023-06-05'),
(102, 'Возвращение из больничного', '2023-06-20'),

-- События для сотрудника 103
(103, 'Начало работы', '2023-01-15'),
(103, 'Премия', '2023-05-01'),
(103, 'Отпуск', '2023-07-01'),
(103, 'Возвращение из отпуска', '2023-07-15'),
(103, 'Окончание работы', '2023-11-30'),

-- События для сотрудника 104
(104, 'Начало работы', '2023-03-01'),
(104, 'Обучение', '2023-04-15'),
(104, 'Повышение', '2023-09-10');
```

## Пример запроса с этими данными

Теперь вы можете выполнить ваш запрос с функцией `LEAD()`:

```sql
SELECT 
    employee_id,
    event_date,
    event_name,
    LEAD(event_date) OVER (PARTITION BY employee_id ORDER BY event_date) AS next_event_date,
    LEAD(event_name) OVER (PARTITION BY employee_id ORDER BY event_date) AS next_event_name
FROM employee_events
ORDER BY employee_id, event_date;
```

## Ожидаемый результат (пример для сотрудника 101):

```
 employee_id | event_date |       event_name       | next_event_date |    next_event_name    
-------------+------------+------------------------+-----------------+----------------------
         101 | 2023-01-10 | Начало работы          | 2023-04-15      | Повышение
         101 | 2023-04-15 | Повышение              | 2023-08-20      | Перевод в другой отдел
         101 | 2023-08-20 | Перевод в другой отдел | 2023-12-05      | Окончание работы
         101 | 2023-12-05 | Окончание работы       | NULL            | NULL
```

Этот пример показывает, как функция `LEAD()` позволяет получить дату и название следующего события для каждого сотрудника, упорядоченного по дате. Для последнего события каждого сотрудника значения будут `NULL`, так как следующего события нет.



# Простые примеры использования `LAG()` в PostgreSQL

Функция `LAG()` похожа на `LEAD()`, но возвращает значение из предыдущей строки вместо следующей. Вот два простых примера:

## Пример 1: Сравнение текущей и предыдущей зарплаты сотрудника

```sql
-- Создаем тестовую таблицу
CREATE TABLE employee_salaries (
    employee_id INT,
    year INT,
    salary DECIMAL(10, 2)
);

-- Заполняем данными
INSERT INTO employee_salaries VALUES
(1, 2020, 50000),
(1, 2021, 52000),
(1, 2022, 55000),
(1, 2023, 58000),
(2, 2021, 45000),
(2, 2022, 47000),
(2, 2023, 50000);

-- Запрос с LAG()
SELECT 
    employee_id,
    year,
    salary,
    LAG(salary) OVER (PARTITION BY employee_id ORDER BY year) AS previous_salary,
    salary - LAG(salary) OVER (PARTITION BY employee_id ORDER BY year) AS salary_increase
FROM employee_salaries;
```

Результат:
```
employee_id | year | salary  | previous_salary | salary_increase
------------+------+---------+-----------------+----------------
          1 | 2020 | 50000.00| NULL            | NULL
          1 | 2021 | 52000.00| 50000.00        | 2000.00
          1 | 2022 | 55000.00| 52000.00        | 3000.00
          1 | 2023 | 58000.00| 55000.00        | 3000.00
          2 | 2021 | 45000.00| NULL            | NULL
          2 | 2022 | 47000.00| 45000.00        | 2000.00
          2 | 2023 | 50000.00| 47000.00        | 3000.00
```

## Пример 2: Анализ временных промежутков между заказами

```sql
-- Создаем тестовую таблицу заказов
CREATE TABLE customer_orders (
    order_id INT,
    customer_id INT,
    order_date DATE
);

-- Заполняем данными
INSERT INTO customer_orders VALUES
(1, 101, '2023-01-05'),
(2, 101, '2023-01-15'),
(3, 101, '2023-02-10'),
(4, 102, '2023-01-10'),
(5, 102, '2023-03-01'),
(6, 103, '2023-02-20');

-- Запрос с LAG()
SELECT 
    order_id,
    customer_id,
    order_date,
    LAG(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) AS previous_order_date,
    order_date - LAG(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) AS days_since_last_order
FROM customer_orders;
```

Результат:
```
order_id | customer_id | order_date | previous_order_date | days_since_last_order
---------+-------------+------------+---------------------+----------------------
       1 |         101 | 2023-01-05 | NULL                | NULL
       2 |         101 | 2023-01-15 | 2023-01-05          | 10
       3 |         101 | 2023-02-10 | 2023-01-15          | 26
       4 |         102 | 2023-01-10 | NULL                | NULL
       5 |         102 | 2023-03-01 | 2023-01-10          | 50
       6 |         103 | 2023-02-20 | NULL                | NULL
```

Функция `LAG()` особенно полезна для анализа изменений во времени и сравнения текущих значений с предыдущими.












# Примеры использования `FIRST_VALUE()` в PostgreSQL

Функция `FIRST_VALUE()` — это оконная функция, которая возвращает первое значение в упорядоченном наборе строк. Вот несколько практических примеров:

## Пример 1: Нахождение первой зарплаты каждого сотрудника

```sql
-- Создаем таблицу зарплат сотрудников
CREATE TABLE employee_salaries (
    employee_id INT,
    year INT,
    salary DECIMAL(10, 2)
);

-- Заполняем данными
INSERT INTO employee_salaries VALUES
(1, 2020, 50000),
(1, 2021, 52000),
(1, 2022, 55000),
(1, 2023, 58000),
(2, 2021, 45000),
(2, 2022, 47000),
(2, 2023, 50000);

-- Запрос с FIRST_VALUE()
SELECT 
    employee_id,
    year,
    salary,
    FIRST_VALUE(salary) OVER (PARTITION BY employee_id ORDER BY year) AS first_salary,
    salary - FIRST_VALUE(salary) OVER (PARTITION BY employee_id ORDER BY year) AS salary_growth
FROM employee_salaries;
```

Результат:
```
employee_id | year | salary  | first_salary | salary_growth
------------+------+---------+--------------+--------------
          1 | 2020 | 50000.00| 50000.00     |      0.00
          1 | 2021 | 52000.00| 50000.00     |   2000.00
          1 | 2022 | 55000.00| 50000.00     |   5000.00
          1 | 2023 | 58000.00| 50000.00     |   8000.00
          2 | 2021 | 45000.00| 45000.00     |      0.00
          2 | 2022 | 47000.00| 45000.00     |   2000.00
          2 | 2023 | 50000.00| 45000.00     |   5000.00
```

## Пример 2: Анализ первого заказа каждого клиента

```sql
-- Создаем таблицу заказов
CREATE TABLE customer_orders (
    order_id INT,
    customer_id INT,
    order_date DATE,
    amount DECIMAL(10, 2)
);

-- Заполняем данными
INSERT INTO customer_orders VALUES
(1, 101, '2023-01-05', 100.00),
(2, 101, '2023-01-15', 150.00),
(3, 101, '2023-02-10', 200.00),
(4, 102, '2023-01-10', 75.00),
(5, 102, '2023-03-01', 125.00),
(6, 103, '2023-02-20', 300.00);

-- Запрос с FIRST_VALUE()
SELECT 
    order_id,
    customer_id,
    order_date,
    amount,
    FIRST_VALUE(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) AS first_order_date,
    FIRST_VALUE(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS first_order_amount,
    amount - FIRST_VALUE(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS amount_increase
FROM customer_orders
ORDER BY customer_id, order_date;
```

Результат:
```
order_id | customer_id | order_date | amount | first_order_date | first_order_amount | amount_increase
---------+-------------+------------+--------+------------------+--------------------+----------------
       1 |         101 | 2023-01-05 | 100.00 | 2023-01-05       | 100.00             |           0.00
       2 |         101 | 2023-01-15 | 150.00 | 2023-01-05       | 100.00             |          50.00
       3 |         101 | 2023-02-10 | 200.00 | 2023-01-05       | 100.00             |         100.00
       4 |         102 | 2023-01-10 |  75.00 | 2023-01-10       |  75.00             |           0.00
       5 |         102 | 2023-03-01 | 125.00 | 2023-01-10       |  75.00             |          50.00
       6 |         103 | 2023-02-20 | 300.00 | 2023-02-20       | 300.00             |           0.00
```

## Ключевые особенности `FIRST_VALUE()`:
1. Всегда требует `OVER()` с указанием `PARTITION BY` и `ORDER BY`
2. Возвращает значение из первой строки окна
3. Полезен для сравнения текущих значений с начальными
4. Часто используется вместе с `LAST_VALUE()` для анализа изменений

Функция особенно полезна для анализа роста показателей, сравнения текущих значений с исходными и выявления тенденций.



# Создание таблицы `employees` с тестовыми данными для демонстрации RANK()

```sql
-- Создаем таблицу employees
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100) NOT NULL,
    department VARCHAR(50) NOT NULL,
    salary DECIMAL(10, 2) NOT NULL,
    hire_date DATE
);

-- Заполняем таблицу тестовыми данными
INSERT INTO employees (employee_name, department, salary, hire_date) VALUES
-- IT отдел
('Иван Петров', 'IT', 95000, '2020-03-15'),
('Алексей Смирнов', 'IT', 85000, '2019-07-22'),
('Елена Козлова', 'IT', 75000, '2021-01-10'),
('Дмитрий Иванов', 'IT', 110000, '2018-05-30'),

-- Финансы
('Ольга Новикова', 'Finance', 90000, '2019-11-12'),
('Михаил Волков', 'Finance', 80000, '2020-08-05'),
('Анна Кузнецова', 'Finance', 70000, '2022-02-18'),

-- Маркетинг
('Сергей Морозов', 'Marketing', 85000, '2020-09-14'),
('Наталья Васнецова', 'Marketing', 65000, '2021-06-27'),
('Артем Лебедев', 'Marketing', 95000, '2019-04-03'),

-- HR
('Виктория Соколова', 'HR', 60000, '2021-03-20'),
('Павел Орлов', 'HR', 55000, '2022-01-15'),
('Екатерина Зайцева', 'HR', 70000, '2020-07-08');
```

## Пример выполнения запроса с RANK()

```sql
SELECT 
	employee_name, 
    employee_id,
    department,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS global_rank,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS department_rank
FROM employees
ORDER BY global_rank;
```

## Ожидаемый результат (первые несколько строк):

```
 employee_id | department |  salary  | global_rank | department_rank
-------------+------------+----------+-------------+-----------------
           4 | IT         | 110000.00|           1 |               1
          11 | Marketing  |  95000.00|           2 |               1
           1 | IT         |  95000.00|           2 |               2
           5 | Finance    |  90000.00|           4 |               1
           8 | Marketing  |  85000.00|           5 |               2
           2 | IT         |  85000.00|           5 |               3
           6 | Finance    |  80000.00|           7 |               2
           3 | IT         |  75000.00|           8 |               4
          13 | HR         |  70000.00|           9 |               1
           7 | Finance    |  70000.00|           9 |               3
          10 | Marketing  |  65000.00|          11 |               3
          12 | HR         |  55000.00|          12 |               2
```

## пример с DENSE_RANK()
```sql
SELECT 
	employee_name, 
    employee_id,
    department,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS global_rank,
    DENSE_RANK()  OVER (ORDER BY salary DESC) AS global_dence_rank,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS department_rank,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_department_rank
FROM employees
ORDER BY global_rank;


```


## Пояснение структуры данных:
1. Таблица содержит информацию о сотрудниках с разными зарплатами в разных отделах
2. В данных специально созданы ситуации с одинаковыми зарплатами:
   - Два сотрудника с зарплатой 95000 (глобальный ранг 2)
   - Два сотрудника с зарплатой 85000 (глобальный ранг 5)
   - Два сотрудника с зарплатой 70000 (глобальный ранг 9)
3. Для каждого отдела вычисляется отдельный рейтинг (department_rank)



## DENSE_RANK()

Функция `DENSE_RANK()` в PostgreSQL используется для ранжирования строк с одинаковыми значениями без пропусков в рангах. В отличие от `RANK()`, она не пропускает ранги, если несколько строк имеют одинаковое значение.

### Пример использования `DENSE_RANK()` в PostgreSQL

Предположим, у нас есть таблица `sales`:

```sql
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    employee TEXT,
    region TEXT,
    amount NUMERIC
);
```

И заполним её данными:

```sql
INSERT INTO sales (employee, region, amount) VALUES
('Alice', 'East', 1000),
('Bob', 'East', 1500),
('Charlie', 'East', 1500),
('Diana', 'East', 900),
('Eve', 'East', 800);
```

Теперь мы хотим присвоить ранг каждому сотруднику в зависимости от их суммы продаж по убыванию:

```sql
SELECT
    employee,
    amount,
    DENSE_RANK() OVER (ORDER BY amount DESC) AS rank
FROM sales;
```

### Результат:

| employee | amount | rank |
| -------- | ------ | ---- |
| Bob      | 1500   | 1    |
| Charlie  | 1500   | 1    |
| Alice    | 1000   | 2    |
| Diana    | 900    | 3    |
| Eve      | 800    | 4    |

Как видно:

* `Bob` и `Charlie` имеют одинаковое значение и получают одинаковый ранг `1`.
* Следующий ранг — `2`, без пропуска.




# ROW_NUMBER()


Функция `ROW_NUMBER()` в PostgreSQL присваивает уникальный порядковый номер каждой строке в пределах заданного окна. В отличие от `RANK()` и `DENSE_RANK()`, она **не учитывает совпадения** — каждой строке дается **уникальный номер**, даже если значения одинаковы.

---

### Пример `ROW_NUMBER()` в PostgreSQL

Представим, у нас есть та же таблица `sales`:

```sql
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    employee TEXT,
    region TEXT,
    amount NUMERIC
);
```

Данные:

```sql
INSERT INTO sales (employee, region, amount) VALUES
('Alice', 'East', 1000),
('Bob', 'East', 1500),
('Charlie', 'East', 1500),
('Diana', 'East', 900),
('Eve', 'East', 800);
```

Теперь присвоим каждой строке номер в зависимости от убывания продаж:

```sql
SELECT
    employee,
    amount,
    ROW_NUMBER() OVER (ORDER BY amount DESC) AS row_num
FROM sales;
```

### Результат:

| employee | amount | row\_num |
| -------- | ------ | -------- |
| Bob      | 1500   | 1        |
| Charlie  | 1500   | 2        |
| Alice    | 1000   | 3        |
| Diana    | 900    | 4        |
| Eve      | 800    | 5        |

### Отличие от DENSE\_RANK():

Если бы вы использовали `DENSE_RANK()`, то `Bob` и `Charlie` имели бы один и тот же ранг (`1`), а `ROW_NUMBER()` дал им уникальные номера.

---



## SUM OVER (PARTITION BY ... ORDER BY ...) 


Вот пример использования агрегатной функции `SUM(*)` с оконной функцией `OVER (PARTITION BY ... ORDER BY ...)` в PostgreSQL — это называется **накапливаемая сумма (running total)** по группам.

---

### Исходная таблица: `sales`

```sql
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    employee TEXT,
    region TEXT,
    sale_date DATE,
    amount NUMERIC
);
```

Данные:

```sql
INSERT INTO sales (employee, region, sale_date, amount) VALUES
('Alice', 'East', '2024-01-01', 100),
('Alice', 'East', '2024-01-02', 200),
('Alice', 'East', '2024-01-03', 150),
('Bob', 'West',  '2024-01-01', 300),
('Bob', 'West',  '2024-01-03', 100),
('Bob', 'West',  '2024-01-04', 200);
```

---

### Задача:

Получить **накопленную сумму `amount` для каждого сотрудника**, отсортированную по дате продажи.

---

### Запрос с оконной функцией:

```sql
SELECT
    employee,
    region,
    sale_date,
    amount,
    SUM(amount) OVER (PARTITION BY employee ORDER BY sale_date) AS running_total
FROM sales
ORDER BY employee, sale_date;
```

---

### Результат:

| employee | region | sale\_date | amount | running\_total |
| -------- | ------ | ---------- | ------ | -------------- |
| Alice    | East   | 2024-01-01 | 100    | 100            |
| Alice    | East   | 2024-01-02 | 200    | 300            |
| Alice    | East   | 2024-01-03 | 150    | 450            |
| Bob      | West   | 2024-01-01 | 300    | 300            |
| Bob      | West   | 2024-01-03 | 100    | 400            |
| Bob      | West   | 2024-01-04 | 200    | 600            |

---

🔹 **`PARTITION BY employee`** — делает накопление отдельно для каждого сотрудника.
🔹 **`ORDER BY sale_date`** — определяет порядок накопления.
🔹 **`SUM(...) OVER (...)`** — превращает агрегатную функцию в оконную, возвращая результат построчно.

```sql
SELECT
    employee,
    sale_date,
    amount,
    AVG(amount) OVER (PARTITION BY employee ORDER BY sale_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg,
    MIN(amount) OVER (PARTITION BY employee ORDER BY sale_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_min
FROM sales
ORDER BY employee, sale_date;
```


Отлично! PostgreSQL поддерживает **расширенные опции `GROUP BY`**: `GROUPING SETS`, `ROLLUP` и `CUBE`. Эти возможности позволяют делать **многомерную агрегацию** (как в OLAP) и заменяют множество объединений (`UNION ALL`) в одном запросе.

---

## 🔹 1. `GROUPING SETS` — Явное указание группировок

Позволяет задавать **наборы группировок**, которые нужно получить.

### Пример:

```sql
SELECT region, employee, SUM(amount)
FROM sales
GROUP BY GROUPING SETS (
  (region, employee),  -- по региону и сотруднику
  (region),            -- только по региону
  ()                   -- общая сумма (всего)
);
```

🟢 Аналог `UNION ALL` трех отдельных `GROUP BY`.

---

## 🔹 2. `ROLLUP` — Иерархическая агрегация

Создает **агрегации по уровням иерархии**: от более детальных к обобщенным.

### Пример:

```sql
SELECT region, employee, SUM(amount)
FROM sales
GROUP BY ROLLUP(region, employee);
```

🔹 Возвращает:

* Сумму по каждому сотруднику в регионе.
* Сумму по региону.
* Общую сумму.

📌 Это эквивалент:

```sql
GROUPING SETS (
  (region, employee),
  (region),
  ()
)
```

---

## 🔹 3. `CUBE` — Полная многомерная агрегация

Вычисляет **все возможные комбинации** группировок по указанным полям.

### Пример:

```sql
SELECT region, employee, SUM(amount)
FROM sales
GROUP BY CUBE(region, employee);
```

🔹 Возвращает:

* Сумму по каждой паре (region, employee),
* Сумму по каждому `region` (все сотрудники),
* Сумму по каждому `employee` (все регионы),
* Общую сумму (все вместе).

📌 Эквивалент:

```sql
GROUPING SETS (
  (region, employee),
  (region),
  (employee),
  ()
)
```

---

## 🔹 Как понять, какие строки обобщенные?

Используйте функцию `GROUPING(...)` — она возвращает `1`, если поле **свернуто (NULL из-за агрегации)**, и `0` если оно реально из данных.

### Пример с `ROLLUP`:

```sql
SELECT
  region,
  employee,
  SUM(amount),
  GROUPING(region) AS is_region_total,
  GROUPING(employee) AS is_employee_total
FROM sales
GROUP BY ROLLUP(region, employee);
```

---

## 🧠 Сравнение:

| Конструкция     | Что делает                                       |
| --------------- | ------------------------------------------------ |
| `GROUPING SETS` | Явно указываешь комбинации группировок           |
| `ROLLUP`        | Делает вложенные уровни иерархии (слева направо) |
| `CUBE`          | Все возможные комбинации                         |

---






Функция `CROSSTAB()` в PostgreSQL — это способ создать **сводную таблицу (pivot table)**, поворачивая строки в **колонки**, аналогично Excel PivotTable. Она входит в расширение **`tablefunc`**, которое нужно сначала включить.

---

## 🔧 1. Как подключить `tablefunc`

```sql
CREATE EXTENSION IF NOT EXISTS tablefunc;
```

---

## 📊 2. Пример задачи

Допустим, у нас есть таблица продаж:

```sql
CREATE TABLE sales (
    employee TEXT,
    month TEXT,
    amount NUMERIC
);
```

### Примерные данные:

```sql
INSERT INTO sales VALUES
('Alice', 'Jan', 100),
('Alice', 'Feb', 150),
('Bob',   'Jan', 200),
('Bob',   'Feb', 250),
('Charlie', 'Jan', 300);
```

---

## 📌 3. Простой `CROSSTAB`

Мы хотим повернуть строки — чтобы каждый сотрудник был в строке, а каждый месяц — в колонке.

### 📘 Синтаксис:

```sql
SELECT *
FROM crosstab(
  $$SELECT employee, month, amount FROM sales ORDER BY 1,2$$
) AS ct(employee TEXT, jan NUMERIC, feb NUMERIC);
```

### 🟢 Результат:

| employee | jan | feb  |
| -------- | --- | ---- |
| Alice    | 100 | 150  |
| Bob      | 200 | 250  |
| Charlie  | 300 | NULL |

---

## ⚠️ Важно

* `crosstab()` **не динамическая** — нужно заранее указать список колонок (`jan`, `feb`, и т.д.).
* Отсутствующие значения (например, у Charlie нет Feb) будут **NULL**.

---

## 📌 4. `CROSSTAB` с двумя входными запросами (гибкий вариант)

Если нужно заранее задать **порядок столбцов**, используем второй параметр:

```sql
SELECT *
FROM crosstab(
  $$SELECT employee, month, amount FROM sales ORDER BY 1,2$$,
  $$SELECT DISTINCT month FROM sales ORDER BY month$$
) AS ct(employee TEXT, jan NUMERIC, feb NUMERIC);
```

---

## 🧠 Когда использовать `CROSSTAB()`:

* Построение сводных таблиц (Pivot Table).
* Генерация отчетов.
* Поворот категорий в фиксированные колонки.

---

Хочешь пример с динамическим количеством колонок (через PL/pgSQL) или с агрегацией (`SUM`, `COUNT`)?



Функция `STRING_AGG()` в PostgreSQL используется для объединения строк в одну, с заданным разделителем — очень полезна для агрегирования текстов.

---

## 📘 Пример на таблице `sales`

Допустим, у нас есть такая таблица:

```sql
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    employee TEXT,
    region TEXT,
    amount NUMERIC
);
```

### Данные:

```sql
INSERT INTO sales (employee, region, amount) VALUES
('Alice', 'East', 100),
('Alice', 'East', 200),
('Bob',   'West', 300),
('Bob',   'West', 400),
('Charlie', 'East', 500);
```

---

## 🔹 Пример 1: список сумм по каждому сотруднику

```sql
SELECT employee,
       STRING_AGG(amount::TEXT, ', ') AS all_sales
FROM sales
GROUP BY employee;
```

🟢 **Результат:**

| employee | all\_sales |
| -------- | ---------- |
| Alice    | 100, 200   |
| Bob      | 300, 400   |
| Charlie  | 500        |

---

## 🔹 Пример 2: список сотрудников по регионам

```sql
SELECT region,
       STRING_AGG(DISTINCT employee, ', ' ORDER BY employee) AS employees
FROM sales
GROUP BY region;
```

🟢 **Результат:**

| region | employees      |
| ------ | -------------- |
| East   | Alice, Charlie |
| West   | Bob            |

---

## 🔹 Пример 3: Составление HTML-списка

```sql
SELECT region,
       '<ul><li>' || STRING_AGG(employee, '</li><li>') || '</li></ul>' AS html_list
FROM sales
GROUP BY region;
```

---

## 🧠 Общий синтаксис:

```sql
STRING_AGG(expression, delimiter [ORDER BY ...])
```

* `expression` — что объединять (обычно текст).
* `delimiter` — разделитель (например, `', '`).
* `ORDER BY` — если важен порядок элементов в агрегате.

---

Хочешь пример с `JSON_AGG()` или сгруппировать данные по датам в текстовом виде?






Отличный вопрос — `TRUNCATE` и `DELETE` в PostgreSQL **оба удаляют данные из таблицы**, но **делают это по-разному**.

---

## 🧨 Главное отличие:

|                       | `DELETE`                         | `TRUNCATE`                      |
| --------------------- | -------------------------------- | ------------------------------- |
| **Скорость**          | Медленно (строка за строкой)     | Очень быстро (обрезает таблицу) |
| **Возврат**           | Можно `ROLLBACK` (да)            | Можно `ROLLBACK` (да)           |
| **Триггеры**          | **Срабатывают** (`AFTER DELETE`) | **Не срабатывают**              |
| **WHERE**             | Да — можно выборочно             | ❌ — удаляет **всё**             |
| **Сброс ID**          | Нет                              | Да (если есть `SERIAL`)         |
| **Блокировки**        | Блокирует строки                 | Блокирует **всю таблицу**       |
| **Влияние на VACUUM** | Требует `VACUUM` после           | Не требует                      |

---

## 🔍 Примеры:

### `DELETE`: удаляет **по условию** и вызывает триггеры

```sql
DELETE FROM sales WHERE employee = 'Alice';
```

* Можно откатить.
* Триггеры `AFTER DELETE` сработают.
* Можно удалить часть данных.

---

### `TRUNCATE`: удаляет **всё** быстро

```sql
TRUNCATE TABLE sales;
```

* Нельзя использовать `WHERE`.
* Очень быстро — очищает таблицу без чтения строк.
* Сбросит счётчик `SERIAL` (если не указать `RESTART IDENTITY OFF`).

---

## ⚠️ Влияние на `SERIAL` / `IDENTITY`

```sql
TRUNCATE TABLE sales RESTART IDENTITY;
-- ID снова начнется с 1
```

```sql
TRUNCATE TABLE sales CONTINUE IDENTITY;
-- ID продолжит с текущего значения
```

---

## ✅ Когда использовать:

| Ситуация                        | Используй                    |
| ------------------------------- | ---------------------------- |
| Удалить выборочно               | `DELETE`                     |
| Нужно вызвать триггеры          | `DELETE`                     |
| Очистить **всю** таблицу быстро | `TRUNCATE`                   |
| Освободить место, сбросить ID   | `TRUNCATE`                   |
| Есть внешние ключи — осторожно! | Лучше `DELETE` или `CASCADE` |

---

Хочешь пример, где `TRUNCATE` не сработает из-за внешнего ключа (`FOREIGN KEY`)?





В PostgreSQL можно управлять **целостностью данных** через ограничения (constraints), такие как:

1. **Внешние ключи (`FOREIGN KEY`)**
2. **Значения по умолчанию (`DEFAULT`)**
3. **Уникальность (`UNIQUE`)**

Вот как добавлять эти ограничения — при создании таблицы и **на уже существующую таблицу**.

---

## 📌 1. **Внешний ключ (`FOREIGN KEY`)**

Обеспечивает ссылочную целостность: значение должно существовать в другой таблице.

### При создании таблицы:

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(id)
);
```

Или явно:

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

### К существующей таблице:

```sql
ALTER TABLE orders
ADD CONSTRAINT fk_customer
FOREIGN KEY (customer_id) REFERENCES customers(id);
```

---

## 📌 2. **Значение по умолчанию (`DEFAULT`)**

Автоматически присваивает значение, если оно не указано при вставке.

### При создании таблицы:

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    price NUMERIC DEFAULT 0.0,
    created_at TIMESTAMP DEFAULT now()
);
```

### К существующей таблице:

```sql
ALTER TABLE products
ALTER COLUMN price SET DEFAULT 0.0;
```

Удалить `DEFAULT`:

```sql
ALTER TABLE products
ALTER COLUMN price DROP DEFAULT;
```

---

## 📌 3. **Уникальное ограничение (`UNIQUE`)**

Гарантирует, что значения в колонке (или наборе колонок) уникальны.

### При создании таблицы:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE
);
```

Или с явным именем:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT,
    CONSTRAINT unique_email UNIQUE (email)
);
```

### К существующей таблице:

```sql
ALTER TABLE users
ADD CONSTRAINT unique_email UNIQUE (email);
```

---

## 🔐 Комбинированные ограничения

Можно добавить `UNIQUE` на несколько колонок:

```sql
ALTER TABLE orders
ADD CONSTRAINT unique_order_combo UNIQUE (customer_id, product_id);
```

---

## 💡 Проверка ограничения (CHECK)

Дополнительно можно задавать ограничения, например:

```sql
ALTER TABLE products
ADD CONSTRAINT check_price_positive CHECK (price > 0);
```

---







### **Материализованные представления (Materialized Views)**

**Материализованные представления** в PostgreSQL — это представления, чьи результаты сохраняются в виде физической таблицы. Они могут значительно повысить производительность, поскольку запросы к ним выполняются быстрее, чем к обычным представлениям, поскольку данные уже вычислены и хранятся в базе данных.

---

## 📌 1. **Создание материализованного представления**

Для создания материализованного представления используется команда `CREATE MATERIALIZED VIEW`. Материализованное представление сохраняет результат запроса в таблице.

### Пример:

```sql
CREATE MATERIALIZED VIEW sales_summary AS
SELECT region, SUM(amount) AS total_sales
FROM sales
GROUP BY region;
```

Этот запрос создаёт представление с результатами агрегации по регионам.

---

## 📌 2. **Обновление материализованного представления**

Чтобы обновить данные в материализованном представлении (так как оно не обновляется автоматически), используется команда `REFRESH MATERIALIZED VIEW`.

### Пример:

```sql
REFRESH MATERIALIZED VIEW sales_summary;
```

### Важное замечание:

* `REFRESH` перезаписывает данные в представлении.
* Это может быть **ресурсоёмкой** операцией, особенно для больших наборов данных.

---

## 📌 3. **Инкрементальное обновление (Partial Refresh)**

PostgreSQL **не поддерживает инкрементальные обновления** для материализованных представлений напрямую, но можно реализовать инкрементальное обновление **с помощью триггеров, временных таблиц и пользовательских функций**. Это полезно, если нужно обновлять только изменённые или добавленные данные.

### Идея:

* Создаём таблицу для хранения изменений (например, добавленные записи).
* Для инкрементального обновления перезагружаем только изменённые части данных.

---

### Пример инкрементального обновления:

Допустим, у нас есть таблица `sales` и материализованное представление `sales_summary`.

1. **Шаг 1: Создаём таблицу изменений (например, добавление новых продаж)**:

```sql
CREATE TABLE sales_changes (
    id SERIAL PRIMARY KEY,
    region TEXT,
    amount NUMERIC,
    change_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

2. **Шаг 2: Триггер для записи изменений в `sales_changes`**:

```sql
CREATE OR REPLACE FUNCTION log_sales_changes() RETURNS trigger AS $$
BEGIN
    INSERT INTO sales_changes (region, amount) VALUES (NEW.region, NEW.amount);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sales_insert_trigger
AFTER INSERT OR UPDATE ON sales
FOR EACH ROW
EXECUTE FUNCTION log_sales_changes();
```

3. **Шаг 3: Функция для инкрементального обновления представления**:

```sql
CREATE OR REPLACE FUNCTION refresh_sales_summary() RETURNS void AS $$
BEGIN
    -- Обновляем только новые или изменённые данные
    INSERT INTO sales_summary (region, total_sales)
    SELECT region, SUM(amount)
    FROM sales_changes
    GROUP BY region
    ON CONFLICT (region) 
    DO UPDATE SET total_sales = EXCLUDED.total_sales;

    -- Очищаем таблицу изменений
    TRUNCATE sales_changes;
END;
$$ LANGUAGE plpgsql;
```

4. **Шаг 4: Планирование инкрементального обновления**:

Вы можете настроить периодическое выполнение инкрементальных обновлений с помощью `pg_cron` или в какой-то момент запускать `refresh_sales_summary()` вручную.

```sql
SELECT refresh_sales_summary();
```

---

### Важное замечание:

* Инкрементальное обновление работает только для **добавленных** или **изменённых** данных. Если в данных произошли **массовые изменения** (например, множество строк было удалено или обновлено), возможно, потребуется полностью обновить материализованное представление.
* Для **очистки** или **полного обновления** можно использовать стандартный `REFRESH MATERIALIZED VIEW`.

---

## 📌 4. **Оптимизация: Индексы на материализованные представления**

Чтобы ускорить запросы к материализованному представлению, можно добавить индексы:

```sql
CREATE INDEX idx_sales_summary_region ON sales_summary(region);
```

Индексы ускоряют поиск по колонкам, особенно если представление большое.

---

## 🧠 Преимущества и недостатки

### Преимущества:

* **Повышенная производительность** при выполнении сложных запросов, так как результат уже вычислен и сохранён.
* **Идеально для отчетности** и аналитики.

### Недостатки:

* **Не обновляется автоматически**. Требует ручного обновления или использования триггеров.
* **Занимает дополнительное пространство** в базе данных для хранения вычисленных данных.

---

Хочешь пример более сложного инкрементального обновления с использованием временных таблиц или с агрегацией за определённый период времени?




### 2. **Создание и использование последовательностей (Sequences)**

**Последовательность (Sequence)** — это объект в PostgreSQL, предназначенный для генерации уникальных чисел, часто используется для создания уникальных значений, например, для первичных ключей.

---

#### 1. **Создание последовательности (Sequence)**

Для создания последовательности используется команда `CREATE SEQUENCE`.

Пример:

```sql
CREATE SEQUENCE seq_employee_id
  START 1
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 1000000
  CACHE 1;
```

* `START 1` — начальное значение последовательности.
* `INCREMENT 1` — шаг последовательности (по умолчанию 1).
* `MINVALUE` и `MAXVALUE` — минимальное и максимальное значения (необязательно).
* `CACHE 1` — количество значений, которые должны быть кэшированы для улучшения производительности.

После создания последовательности можно использовать её для получения значений.

---

#### 2. **Использование Sequence как Default значение при создании таблицы**

Можно использовать последовательность как значение по умолчанию для поля, например, для создания уникальных значений первичного ключа.

Пример:

```sql
CREATE TABLE employees (
    id INT DEFAULT nextval('seq_employee_id') PRIMARY KEY,
    name TEXT NOT NULL
);
```

Здесь `nextval('seq_employee_id')` будет вызываться для генерации следующего уникального значения для столбца `id` при вставке новой строки.

---

#### 3. **Использование Sequence в других запросах**

Для получения следующего значения последовательности можно использовать функцию `nextval`:

```sql
SELECT nextval('seq_employee_id');
```

Если нужно получить текущее значение последовательности без её увеличения, используется `currval`:

```sql
SELECT currval('seq_employee_id');
```

Для установки значения последовательности вручную используется `setval`:

```sql
SELECT setval('seq_employee_id', 1000);
```

Это установит значение последовательности в `1000`. При следующем вызове `nextval` будет возвращено значение `1001`.

---

#### 4. **Реинициализация Sequence**

Если необходимо **перезагрузить** последовательность, например, начать снова с определённого значения, используйте функцию `setval`:

```sql
SELECT setval('seq_employee_id', 1, false);
```

* Первый параметр — это имя последовательности.
* Второй параметр — значение, которое должно быть установлено.
* Третий параметр (если `false`) указывает, что следующее значение будет равно 1, а не 2 (если было установлено на 1).

Также можно установить последовательность на максимальное значение, если таблица была очищена или изменения не были отражены:

```sql
SELECT setval('seq_employee_id', (SELECT max(id) FROM employees));
```

---

### Пример использования Sequence в реальном контексте:

1. Создаём таблицу с последовательностью:

```sql
CREATE SEQUENCE seq_order_id START 1;
```

```sql
CREATE TABLE orders (
    order_id INT DEFAULT nextval('seq_order_id') PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT NOT NULL
);
```

2. Вставляем данные в таблицу:

```sql
INSERT INTO orders (order_date, customer_id) VALUES ('2025-05-07', 1);
INSERT INTO orders (order_date, customer_id) VALUES ('2025-05-08', 2);
```

Каждый заказ будет получать уникальный идентификатор, генерируемый с помощью последовательности.

---

### Заключение

* **Последовательности** в PostgreSQL очень удобны для генерации уникальных значений, например, для первичных ключей.
* **Использование `nextval`** и `setval` позволяет управлять значениями последовательности.
* Вы можете использовать последовательности в качестве **значений по умолчанию** для столбцов таблиц.





# Создание индексов и типы индексов в PostgreSQL

**Индексы** — это специальные объекты базы данных, которые ускоряют поиск строк в таблицах. Они позволяют значительно повысить производительность запросов, которые часто выполняют операции с фильтрацией, сортировкой или объединением данных. Однако индексы увеличивают время на вставку, обновление и удаление данных, так как индекс нужно обновлять.

---

### 1. **Создание индекса**

Индексы создаются с помощью команды `CREATE INDEX`.

Пример:

```sql
CREATE INDEX idx_employee_name ON employees(name);
```

Этот запрос создаёт индекс на столбец `name` в таблице `employees`. Индекс поможет ускорить поиск сотрудников по имени.

---

### 2. **Типы индексов в PostgreSQL**

В PostgreSQL доступно несколько типов индексов. Каждый тип индекса оптимизирован для определённых операций или типов данных.

#### **1. B-tree (По умолчанию)**

**B-tree** — это тип индекса, который является **по умолчанию** в PostgreSQL. Он идеально подходит для большинства типов данных, таких как `INTEGER`, `TEXT`, `DATE`, и поддерживает операции **равенства** и **диапазона**.

Пример:

```sql
CREATE INDEX idx_employee_id ON employees(id);
```

Индекс **B-tree** эффективно работает для операций:

* `=`, `<`, `<=`, `>`, `>=`, `BETWEEN`, `IN` и другие.

#### **2. Hash**

Индекс **Hash** используется для оптимизации операций **равенства** (`=`), но не поддерживает операции диапазона. В PostgreSQL этот тип индекса обычно используется для оптимизации поиска по точному значению.

Пример:

```sql
CREATE INDEX idx_employee_name_hash ON employees USING HASH (name);
```

Однако стоит отметить, что **B-tree** индекс часто предпочтительнее для большинства операций, а использование индекса **Hash** может быть ограничено.

#### **3. GiST (Generalized Search Tree)**

**GiST** — это обобщённый индекс, который используется для **пользовательских типов данных** и сложных запросов, таких как поиск по географическим данным, поиск по текстовым данным и другие.

Пример создания индекса для географических данных (например, с использованием расширения PostGIS):

```sql
CREATE INDEX idx_location ON locations USING GIST (location);
```

#### **4. GIN (Generalized Inverted Index)**

**GIN** — это индекс, оптимизированный для **поиска по набору значений** и работы с **массивами**, **текстовыми поисковыми индексами** или **JSONB**.

Пример для индексации текстового поиска:

```sql
CREATE INDEX idx_search_text ON documents USING GIN (to_tsvector('english', content));
```

Этот тип индекса отлично подходит для **полнотекстового поиска** и **поиска по массивам**.

#### **5. SP-GiST (Space-partitioned Generalized Search Tree)**

**SP-GiST** — это разновидность **GiST** индекса, который используется для **пространственных данных** и других типов данных с **деревьями** (например, для поиска ближайших точек или поиска по пространственным данным).

Пример:

```sql
CREATE INDEX idx_spgist_location ON locations USING SPGIST (location);
```

#### **6. BRIN (Block Range INdexes)**

**BRIN** — это индекс, оптимизированный для таблиц с **большими объемами данных**, где значения в столбцах имеют естественный порядок, как, например, данные с временными метками.

Пример:

```sql
CREATE INDEX idx_brin_timestamp ON events USING BRIN (event_time);
```

Этот индекс эффективен для очень больших таблиц с упорядоченными данными (например, временные метки или порядковые номера).

---

### 3. **Использование индексов для производительности**

#### **1. Индексы на нескольких столбцах (Composite Index)**

Индексы могут быть созданы на нескольких столбцах, что может ускорить запросы, которые используют несколько фильтров.

Пример:

```sql
CREATE INDEX idx_employee_dept_salary ON employees(department, salary);
```

Этот индекс будет полезен для запросов, которые фильтруют данные по **`department`** и **`salary`**.

#### **2. Индекс с выражением (Function-Based Index)**

Индексы также можно создавать на выражениях или результатах функций. Это полезно для создания индекса на результатах вычислений.

Пример:

```sql
CREATE INDEX idx_lower_name ON employees (LOWER(name));
```

Этот индекс ускоряет поиск по строкам, игнорируя регистр символов.

#### **3. Индексы с уникальностью (Unique Index)**

Индекс с ограничением уникальности создаётся автоматически при добавлении ограничения `UNIQUE`. Этот индекс гарантирует, что все значения в столбце или наборе столбцов будут уникальными.

Пример:

```sql
CREATE UNIQUE INDEX idx_unique_email ON employees(email);
```

Этот индекс гарантирует, что все email-адреса в таблице будут уникальными.

---

### 4. **Удаление индекса**

Для удаления индекса используется команда `DROP INDEX`.

Пример:

```sql
DROP INDEX IF EXISTS idx_employee_name;
```

---

### 5. **Использование индексов в запросах**

PostgreSQL автоматически решает, когда использовать индекс, в зависимости от статистики данных и типа запроса. Однако, индексы также можно проверять вручную, например, через команду `EXPLAIN`.

Пример:

```sql
EXPLAIN SELECT * FROM employees WHERE name = 'John';
```

Если индекс используется, PostgreSQL покажет это в плане выполнения запроса.

---

### 6. **Индексы и производительность**

* Индексы ускоряют **поиск** и **сортировку**, но могут замедлять **вставку**, **обновление** и **удаление данных**, так как индексы нужно обновлять при изменении данных.
* Индексы увеличивают **использование дискового пространства**.
* Индексы эффективны для **часто выполняемых запросов**, но не всегда необходимы для таблиц с редкими запросами или с небольшим количеством данных.

---

Если ты хочешь узнать, как выбирать подходящий тип индекса для определённых запросов или других аспектов производительности, не стесняйся спрашивать!





